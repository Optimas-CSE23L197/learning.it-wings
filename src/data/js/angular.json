{
  "course": {
    "id": "angular",
    "title": "Angular Tutorial",
    "description": "Complete Angular course from basics to advanced concepts."
  },

  "sections": [
    {
      "title": "Angular Basics",
      "lessons": [
        { "id": "angular-home", "title": "Angular Home" },
        { "id": "angular-intro", "title": "Angular Intro" },
        { "id": "angular-get-started", "title": "Angular Get Started" },
        { "id": "angular-first-app", "title": "Angular First App" },
        { "id": "angular-templates", "title": "Angular Templates" },
        {
          "id": "angular-templates-interpolation",
          "title": "Angular Templates: Interpolation"
        },
        {
          "id": "angular-template-reference-variables",
          "title": "Angular Template Reference Variables"
        },
        {
          "id": "angular-null-safe-navigation",
          "title": "Angular Templates: Null-Safe Navigation (?.)"
        },
        {
          "id": "angular-structural-directives-micro-syntax",
          "title": "Angular Templates: Structural Directives Micro-syntax"
        },
        {
          "id": "angular-ngTemplateOutlet",
          "title": "Angular Templates: ngTemplateOutlet"
        },
        {
          "id": "angular-template-statements",
          "title": "Angular Template Statements and $event"
        },
        {
          "id": "angular-template-alias-as",
          "title": "Angular Templates: Alias with as in *ngIf"
        },
        {
          "id": "angular-template-attribute-binding",
          "title": "Angular Templates: Attribute Binding with attr."
        },
        {
          "id": "angular-template-trackby",
          "title": "Angular Templates: TrackBy with *ngFor"
        },
        { "id": "angular-components", "title": "Angular Components" },
        { "id": "angular-data-binding", "title": "Angular Data Binding" },
        { "id": "angular-directives", "title": "Angular Directives" },
        { "id": "angular-events", "title": "Angular Events" },
        { "id": "angular-conditional", "title": "Angular Conditional" },
        { "id": "angular-lists", "title": "Angular Lists" },
        { "id": "angular-forms", "title": "Angular Forms" },
        { "id": "angular-router", "title": "Angular Router" },
        { "id": "angular-services-di", "title": "Angular Services & DI" },
        { "id": "angular-http-client", "title": "Angular HTTP Client" },
        { "id": "angular-pipes", "title": "Angular Pipes" },
        { "id": "angular-lifecycle", "title": "Angular Lifecycle Hooks" },
        { "id": "angular-styling", "title": "Angular Styling" }
      ]
    },

    {
      "title": "Advanced Angular",
      "lessons": [
        { "id": "angular-bootstrap", "title": "Angular App Bootstrap" },
        { "id": "angular-control-flow", "title": "Angular Control Flow" },
        { "id": "angular-signals", "title": "Angular Signals" },
        {
          "id": "angular-change-detection",
          "title": "Angular Change Detection"
        },
        {
          "id": "angular-dynamic-components",
          "title": "Angular Dynamic Components"
        },
        {
          "id": "angular-advanced-di",
          "title": "Angular Services & Dependency Injection"
        },
        { "id": "angular-router-advanced", "title": "Angular Router Advanced" },
        {
          "id": "angular-http-interceptors",
          "title": "Angular HTTP Interceptors"
        },
        { "id": "angular-forms-advanced", "title": "Angular Forms Advanced" },
        {
          "id": "angular-state-management",
          "title": "Angular State Management"
        },
        { "id": "angular-animations", "title": "Angular Animations" },
        { "id": "angular-testing", "title": "Angular Testing" },
        { "id": "angular-security", "title": "Angular Security" },
        { "id": "angular-ssr", "title": "Angular SSR & Hydration" }
      ]
    }
  ],

  "content": {
    "angular-home": {
      "title": "Angular Home",
      "sections": [
        {
          "heading": "Learn Angular",
          "paragraphs": [
            "Angular is a framework for building client applications in HTML and TypeScript.",
            "It is developed and maintained by Google.",
            "Angular helps build fast, scalable, and maintainable web applications."
          ]
        },
        {
          "heading": "Overview & Prerequisites",
          "paragraphs": [
            "This tutorial teaches Angular step-by-step with easy-to-follow examples.",
            "It uses standalone components, modern control flow, the Angular Router, and HttpClient.",
            "The examples are simple and focus on practical usage."
          ],
          "prerequisites": [
            "Basic knowledge of HTML",
            "Basic knowledge of CSS",
            "Basic knowledge of JavaScript",
            "TypeScript knowledge is helpful but not required"
          ]
        },
        {
          "heading": "Learning by Examples",
          "paragraphs": [
            "Angular provides a live editor to show code and output together.",
            "Users can edit the code and instantly see results."
          ],
          "example": {
            "title": "Hello Angular Example",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `<h1>Hello Angular!</h1>`\n})\nexport class App {}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Learning by Exercises",
          "paragraphs": [
            "Each chapter contains exercises to test understanding.",
            "Users can submit answers and track their progress."
          ],
          "exercise": {
            "question": "Angular is a:",
            "options": ["Library", "Framework", "Programming Language"],
            "correct_answer": "Framework"
          }
        },
        {
          "heading": "Angular Quiz",
          "paragraphs": [
            "Angular quizzes help test your knowledge.",
            "They cover concepts from beginner to advanced level."
          ]
        },
        {
          "heading": "Track Your Progress",
          "paragraphs": [
            "Users can sign in to track progress.",
            "Features include progress tracking, quizzes, leaderboards, and certificates.",
            "Creating an account is optional."
          ]
        }
      ]
    },

    "angular-intro": {
      "title": "Angular Intro",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Angular helps you build scalable single-page applications using TypeScript.",
            "It is a full-featured front-end framework developed by Google."
          ]
        },
        {
          "heading": "What is Angular?",
          "points": [
            "Angular is a full-featured front-end framework for building web applications.",
            "Built with TypeScript",
            "Uses components and templates",
            "Includes routing, forms, HTTP, and dependency injection",
            "Supports standalone APIs (no NgModules needed)",
            "Works great for single-page applications (SPAs)"
          ]
        },
        {
          "heading": "How Angular Works",
          "points": [
            "Angular compiles templates into efficient JavaScript",
            "Automatically updates the DOM when data changes",
            "Uses HTML-based templates",
            "Supports data binding with directives",
            "Handles user input and events",
            "Fetches data using HttpClient",
            "Uses Router for navigation"
          ]
        },
        {
          "heading": "What You Should Already Know",
          "requirements": [
            "HTML",
            "CSS",
            "JavaScript",
            "Basic TypeScript (recommended)"
          ]
        },
        {
          "heading": "Angular Example",
          "example": {
            "description": "Simple Angular standalone component example",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `<h2>Welcome to Angular!</h2>`\n})\nexport class App {}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Exercise",
          "question": "Angular is a:",
          "options": ["Library", "Framework", "Programming Language"],
          "correct_answer": "Framework"
        }
      ]
    },

    "angular-get-started": {
      "title": "Angular Get Started",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "To use Angular, you need Node.js and npm installed on your system.",
            "Angular uses Node.js for its CLI tools and build process."
          ]
        },
        {
          "heading": "Check Node.js Installation",
          "steps": [
            "Run the following command to check Node.js:",
            "node -v",
            "This prints the installed Node.js version (e.g., v20.x.x).",
            "Angular works best with the current LTS version (18 or 20).",
            "If Node.js is not installed, install it from the official Node.js website."
          ]
        },
        {
          "heading": "Check npm Version",
          "steps": [
            "Run the following command:",
            "npm -v",
            "npm is Node.js package manager and is installed automatically with Node.js.",
            "It prints the installed npm version (e.g., 10.x.x)."
          ]
        },
        {
          "heading": "Install Angular CLI",
          "description": "The Angular CLI is the official tool for creating and managing Angular projects.",
          "commands": ["npm install -g @angular/cli"],
          "notes": [
            "Installing globally allows using the ng command anywhere.",
            "You can also use npx if you don't want a global install.",
            "If permission issues occur, use npx or run the terminal as administrator."
          ]
        },
        {
          "heading": "Verify Angular CLI",
          "commands": ["ng version"],
          "output_example": [
            "Angular CLI: 18.x.x",
            "Node: 20.x.x",
            "Package Manager: npm 10.x.x"
          ],
          "description": "This confirms Angular CLI and Node.js are correctly installed."
        },
        {
          "heading": "Create an Angular Application",
          "steps": [
            "Create a new Angular project:",
            "ng new my-angular-app",
            "Choose CSS as stylesheet format.",
            "Choose No for SSR and Zoneless options.",
            "Keep other defaults."
          ],
          "alternative": "npx @angular/cli@latest new my-angular-app"
        },
        {
          "heading": "Run the Angular Application",
          "steps": [
            "cd my-angular-app",
            "ng serve",
            "Open browser at http://localhost:4200",
            "Use --open to auto-open the browser"
          ]
        },
        {
          "heading": "Exercise",
          "question": "What command can you use to check if Node.js is installed?",
          "options": ["node -v", "node.js installed", "npm installed"],
          "correct_answer": "node -v"
        }
      ]
    },

    "angular-first-app": {
      "title": "Angular First App",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Now that your environment is ready, let's create a simple Angular app.",
            "Angular 20 applications bootstrap a standalone root component."
          ]
        },
        {
          "heading": "Step 1: Open src/main.ts",
          "description": [
            "Angular apps bootstrap a standalone root component.",
            "You can define the component directly in main.ts."
          ],
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `<h1>Hello, World!</h1>`\n})\nclass App {}\n\nbootstrapApplication(App);"
          },
          "note": "Live reload automatically refreshes the browser when changes are saved."
        },
        {
          "heading": "Quick Primer: Components",
          "points": [
            "A component is a class that controls a view",
            "Each component has a selector used in HTML",
            "The root component renders inside index.html",
            "Components will be explored in detail later"
          ]
        },
        {
          "heading": "Step 2: Host Element in index.html",
          "description": [
            "Angular renders the root component where its selector appears.",
            "The selector must match the component selector."
          ],
          "example": {
            "file": "index.html",
            "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>My Angular App</title>\n    <base href=\"/\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <app-root></app-root>\n  </body>\n</html>"
          },
          "note": "Keep <base href=\"/\"> in the head so routing works correctly."
        },
        {
          "heading": "Step 3: Bind Some Data",
          "description": "Use interpolation to bind data from the component to the template.",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `<h1>Hello, {{ name }}!</h1>`\n})\nclass App { name = 'Angular 20'; }\n\nbootstrapApplication(App);"
          },
          "notes": [
            "Interpolation updates the UI automatically",
            "Keep template expressions simple",
            "Prefer properties over method calls for performance"
          ]
        },
        {
          "heading": "Project Structure",
          "files": [
            "src/main.ts – Bootstraps the application",
            "src/app/app.component.ts – Root component (optional)",
            "src/app/ – Application features and components",
            "src/index.html – Host page",
            "src/styles.css – Global styles",
            "angular.json – Project configuration",
            "package.json – Dependencies and scripts"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which API boots a standalone Angular component in main.ts?",
          "options": [
            "bootstrapApplication",
            "bootstrapModule",
            "platformBrowserDynamic"
          ],
          "correct_answer": "bootstrapApplication"
        }
      ]
    },

    "angular-templates": {
      "title": "Angular Templates",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Templates are the HTML that a component renders.",
            "They combine standard HTML with Angular template syntax to display data and respond to user actions."
          ]
        },
        {
          "heading": "Components, Templates, and Selectors",
          "points": [
            "A component is a class that controls a view (its template)",
            "Each component has a selector (e.g., app-root)",
            "The root component renders inside index.html",
            "Templates define how the UI looks and behaves"
          ]
        },
        {
          "heading": "How Templates Work",
          "points": [
            "Angular creates the component and processes the template",
            "Bindings connect the DOM to component data",
            "Change detection updates only modified parts",
            "Directives create or remove DOM elements",
            "Interpolation and bindings pass data between view and component"
          ],
          "note": "Interpolation escapes HTML for security."
        },
        {
          "heading": "Template Syntax Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Hello {{ name }}</h3>\n    <button (click)=\"name = 'Angular'\">Reset</button>\n  `\n})\nexport class App {\n  name = 'World';\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Example Explanation",
          "points": [
            "{{ name }} uses interpolation to display data",
            "(click) binds a button click event",
            "Template expressions run in component context",
            "Avoid heavy logic in templates"
          ]
        },
        {
          "heading": "Template Essentials",
          "points": [
            "Templates define the UI for components",
            "Interpolation: {{ value }}",
            "Property binding: [property]",
            "Event binding: (event)",
            "Template reference variables: #var",
            "Structural directives: *ngIf, *ngFor"
          ],
          "examples": [
            "<p>Hello {{ name }}</p>",
            "<img [src]=\"url\" (error)=\"onMissing()\">",
            "<input #box (input)=\"save(box.value)\">",
            "<li *ngFor=\"let item of items; index as i\">{{ i }}. {{ item }}</li>"
          ]
        },
        {
          "heading": "Code Explanation",
          "points": [
            "{{ name }} → Interpolation",
            "[src] → Property binding",
            "(error) → Event binding",
            "#box → Template reference variable",
            "*ngFor → Structural directive with index"
          ]
        },
        {
          "heading": "Templates Overview",
          "topics": [
            "Interpolation",
            "Template Reference Variables",
            "Null-Safe Navigation (?.)",
            "Structural Directives (*ngIf, *ngFor)",
            "ngTemplateOutlet",
            "Template Statements and $event",
            "Alias with as",
            "Pipes in Templates",
            "Attribute Binding",
            "TrackBy with *ngFor"
          ]
        },
        {
          "heading": "Exercise",
          "question": "What is an Angular template?",
          "options": [
            "The HTML that a component renders (HTML + Angular syntax)",
            "A service responsible for fetching data",
            "The TypeScript class that holds component logic"
          ],
          "correct_answer": "The HTML that a component renders (HTML + Angular syntax)"
        }
      ]
    },

    "angular-templates-interpolation": {
      "title": "Angular Templates: Interpolation",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Interpolation displays component values in the DOM using double curly braces.",
            "It is one-way data binding from the component to the view."
          ]
        },
        {
          "heading": "What is Interpolation?",
          "points": [
            "Displays values using {{ ... }} syntax",
            "Reads data from the component class",
            "One-way binding: data → view",
            "Automatically updates when data changes"
          ]
        },
        {
          "heading": "When to Use Interpolation",
          "points": [
            "To show text values",
            "For simple expressions",
            "When no DOM property binding is required",
            "For fast and safe rendering"
          ],
          "note": "For dynamic attributes or HTML rendering, use property binding instead."
        },
        {
          "heading": "Syntax",
          "syntax": "{{ expression }}"
        },
        {
          "heading": "Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>{{ title }}</h3>\n    <p>Hello {{ name }}!</p>\n    <p>2 + 3 = {{ 2 + 3 }}</p>\n    <p>Upper: {{ name.toUpperCase() }}</p>\n  `\n})\nexport class App {\n  title = 'Templates & Interpolation';\n  name = 'Angular';\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Example Explanation",
          "points": [
            "{{ title }} and {{ name }} display component properties",
            "{{ 2 + 3 }} evaluates an expression",
            "{{ name.toUpperCase() }} calls a string method",
            "HTML is escaped automatically for safety"
          ]
        },
        {
          "heading": "Important Rules",
          "points": [
            "Interpolation escapes HTML",
            "Avoid heavy computations inside {{ }}",
            "Do not change component state in templates",
            "Use [innerHTML] carefully for HTML rendering"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which syntax renders a component property into the template?",
          "options": [
            "{{ }} (interpolation)",
            "[prop] (property binding)",
            "(event) (event binding)"
          ],
          "correct_answer": "{{ }} (interpolation)"
        }
      ]
    },

    "angular-template-reference-variables": {
      "title": "Angular Template Reference Variables",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Template reference variables allow you to assign a local name to an element or directive.",
            "They are used to read values or call methods directly from the template."
          ]
        },
        {
          "heading": "What is a Template Reference Variable?",
          "points": [
            "Defined using #variableName",
            "Creates a reference to a DOM element or directive instance",
            "Accessible only inside the template where it is declared",
            "Used without needing extra bindings"
          ]
        },
        {
          "heading": "When to Use Template Reference Variables",
          "points": [
            "To read input values",
            "To focus or manipulate elements",
            "To access directive or component APIs",
            "For simple UI interactions"
          ],
          "note": "For complex logic, use component properties and methods instead."
        },
        {
          "heading": "Basic Example",
          "example": {
            "code": "<input #box (input)=\"val = box.value\">\n<button (click)=\"box.focus()\">Focus</button>"
          }
        },
        {
          "heading": "Example Explanation",
          "points": [
            "#box creates a reference to the input element",
            "box.value reads the input value",
            "box.focus() calls the native focus() method"
          ]
        },
        {
          "heading": "Full Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  styles: [`\n    .toolbar { display: flex; gap: 8px; align-items: center; }\n    input { padding: 6px 8px; }\n  `],\n  template: `\n    <h3>Template Reference Variables (#var)</h3>\n    <div class=\"toolbar\">\n      <input #box type=\"text\" placeholder=\"Type something\" (input)=\"current = box.value\" />\n      <button (click)=\"read(box.value)\">Read value</button>\n      <button (click)=\"box.focus()\">Focus input</button>\n      <span>length={{ box.value?.length || 0 }}</span>\n    </div>\n    <p>Current: {{ current || '(empty)' }}</p>\n  `\n})\nexport class App {\n  current = '';\n  read(val: string) {\n    this.current = val ?? '';\n  }\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Key Notes",
          "points": [
            "Template reference variables exist only inside the template",
            "They reference DOM elements or directive instances",
            "They do not replace component state",
            "Use them for quick DOM access"
          ]
        },
        {
          "heading": "Exercise",
          "question": "What does a template reference variable (e.g., #input) give you?",
          "options": [
            "A global variable accessible from any component",
            "A way to import a service",
            "A reference to a DOM element or directive instance"
          ],
          "correct_answer": "A reference to a DOM element or directive instance"
        }
      ]
    },

    "angular-null-safe-navigation": {
      "title": "Angular Templates: Null-Safe Navigation (?.)",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Null-safe navigation (?.) allows safe access to properties that may be null or undefined.",
            "It prevents runtime errors when working with optional or async data."
          ]
        },
        {
          "heading": "What is Null-Safe Navigation (?.)?",
          "points": [
            "Safely reads values that might be null or undefined",
            "Stops evaluation if any part of the chain is missing",
            "Prevents template errors",
            "Returns undefined instead of throwing an error"
          ]
        },
        {
          "heading": "When to Use Null-Safe Navigation",
          "points": [
            "When working with async data",
            "When object properties may not exist yet",
            "To avoid multiple conditional checks",
            "When binding nested values"
          ]
        },
        {
          "heading": "Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <button (click)=\"toggle()\">Toggle user</button>\n    <p>Email: {{ user?.profile?.email || '(none)' }}</p>\n  `\n})\nexport class App {\n  user: { profile?: { email?: string } } | undefined = undefined;\n\n  toggle() {\n    this.user = this.user\n      ? undefined\n      : { profile: { email: 'a@example.com' } };\n  }\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Example Explanation",
          "points": [
            "user?.profile?.email safely accesses nested properties",
            "If user or profile is undefined, no error is thrown",
            "|| '(none)' provides a fallback display value",
            "Toggle button switches between defined and undefined values"
          ]
        },
        {
          "heading": "Nullish Coalescing (??)",
          "points": [
            "Use ?? instead of || when falsy values like 0 or '' should be preserved",
            "Example: value ?? 'default'",
            "Useful when empty strings or zero are valid values"
          ]
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use ?. for optional or async data",
            "Avoid deep chains when possible",
            "Combine with ?? for safer defaults",
            "Do not use for required values"
          ]
        },
        {
          "heading": "Exercise",
          "question": "What does the null-safe navigation operator (?.) do in Angular templates?",
          "options": [
            "Converts values to null when falsy",
            "Triggers change detection on null values",
            "Prevents errors when accessing possibly null or undefined values"
          ],
          "correct_answer": "Prevents errors when accessing possibly null or undefined values"
        }
      ]
    },
    "angular-structural-directives-micro-syntax": {
      "title": "Angular Templates: Structural Directives Micro-syntax",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Structural directives change the DOM structure by adding or removing elements.",
            "The * syntax is shorthand for Angular's <ng-template> syntax."
          ]
        },
        {
          "heading": "What is Structural Directive Micro-syntax?",
          "points": [
            "* is shorthand syntax expanded into <ng-template>",
            "Used by directives like *ngIf and *ngFor",
            "Provides context variables like index, else, and let",
            "Angular rewrites this syntax internally"
          ]
        },
        {
          "heading": "When to Use Micro-syntax",
          "points": [
            "To conditionally render content",
            "To loop over lists using *ngFor",
            "For cleaner and more readable templates",
            "Use <ng-template> explicitly when advanced control is needed"
          ]
        },
        {
          "heading": "Example",
          "example": {
            "code": "<div *ngIf=\"ok; else other\">OK</div>\n<ng-template #other>Not OK</ng-template>\n\n<li *ngFor=\"let item of items; index as i\">\n  {{ i }} {{ item }}\n</li>"
          }
        },
        {
          "heading": "Example Explained",
          "points": [
            "*ngIf=\"ok; else other\" renders content based on condition",
            "#other references an alternate template",
            "*ngFor iterates over items array",
            "index as i exposes the loop index",
            "Angular rewrites * syntax into <ng-template>"
          ]
        },
        {
          "heading": "Full Working Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <button (click)=\"ok = !ok\">Toggle</button>\n\n    <div *ngIf=\"ok; else other\">OK</div>\n    <ng-template #other>Not OK</ng-template>\n\n    <ul>\n      <li *ngFor=\"let item of items; index as i\">\n        {{ i }} - {{ item }}\n      </li>\n    </ul>\n  `\n})\nexport class App {\n  ok = true;\n  items = ['A', 'B', 'C'];\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Key Notes",
          "points": [
            "*ngIf and *ngFor are structural directives",
            "The * is syntactic sugar for <ng-template>",
            "index as i exposes loop index",
            "Angular 17+ introduces @if and @for as modern alternatives",
            "Micro-syntax is still widely used and supported"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which directive uses the micro-syntax (asterisk form) to render lists?",
          "options": ["rndList", "*ngFor", "microList"],
          "correct_answer": "*ngFor"
        }
      ]
    },

    "angular-ngTemplateOutlet": {
      "title": "Angular Templates: ngTemplateOutlet",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "ngTemplateOutlet is used to render a reusable <ng-template> dynamically.",
            "It allows passing data into templates and selecting which template to render at runtime."
          ]
        },
        {
          "heading": "What is ngTemplateOutlet?",
          "points": [
            "<ng-template> defines a reusable template block",
            "[ngTemplateOutlet] renders the selected template",
            "[ngTemplateOutletContext] passes data into the template",
            "Template variables are accessed using let- syntax"
          ]
        },
        {
          "heading": "When to Use ngTemplateOutlet",
          "points": [
            "Reuse UI fragments with different data",
            "Switch templates dynamically",
            "Avoid duplicating markup",
            "Use components instead when logic becomes complex"
          ]
        },
        {
          "heading": "Example",
          "example": {
            "code": "<ng-container\n  [ngTemplateOutlet]=\"type === 'info' ? infoTpl : (type === 'warning' ? warnTpl : successTpl)\"\n  [ngTemplateOutletContext]=\"{ $implicit: msg }\">\n</ng-container>\n\n<ng-template #infoTpl let-text>\n  <p style=\"color:royalblue\">Info: {{ text }}</p>\n</ng-template>\n\n<ng-template #warnTpl let-text>\n  <p style=\"color:darkorange\">Warning: {{ text }}</p>\n</ng-template>\n\n<ng-template #successTpl let-text>\n  <p style=\"color:seagreen\">Success: {{ text }}</p>\n</ng-template>"
          }
        },
        {
          "heading": "Full Working Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <h3>Templates with ngTemplateOutlet</h3>\n\n    <select (change)=\"type = $any($event.target).value\">\n      <option value=\"info\">info</option>\n      <option value=\"warning\">warning</option>\n      <option value=\"success\">success</option>\n    </select>\n\n    <input (input)=\"msg = $any($event.target).value\" [value]=\"msg\" />\n\n    <ng-container\n      [ngTemplateOutlet]=\"type === 'info' ? infoTpl : (type === 'warning' ? warnTpl : successTpl)\"\n      [ngTemplateOutletContext]=\"{ $implicit: msg }\">\n    </ng-container>\n\n    <ng-template #infoTpl let-text>\n      <p style=\"color:royalblue\">Info: {{ text }}</p>\n    </ng-template>\n\n    <ng-template #warnTpl let-text>\n      <p style=\"color:darkorange\">Warning: {{ text }}</p>\n    </ng-template>\n\n    <ng-template #successTpl let-text>\n      <p style=\"color:seagreen\">Success: {{ text }}</p>\n    </ng-template>\n  `\n})\nexport class App {\n  type: 'info' | 'warning' | 'success' = 'info';\n  msg = 'Hello';\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Key Concepts",
          "points": [
            "<ng-template> is not rendered until referenced",
            "ngTemplateOutlet selects which template to render",
            "ngTemplateOutletContext passes data into templates",
            "$implicit is the default variable name",
            "<ng-container> avoids adding extra DOM elements"
          ]
        },
        {
          "heading": "Exercise",
          "question": "What does ngTemplateOutlet do?",
          "options": [
            "Renders a <ng-template> at a specific place",
            "Creates a new component dynamically",
            "Defines a pipe"
          ],
          "correct_answer": "Renders a <ng-template> at a specific place"
        }
      ]
    },

    "angular-template-statements": {
      "title": "Angular Template Statements and $event",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Template statements allow you to respond to user events in Angular templates.",
            "They are written inside event bindings like (click), (input), etc.",
            "$event gives access to the native browser event object."
          ]
        },
        {
          "heading": "What are Template Statements?",
          "points": [
            "Executed when an event occurs",
            "Used with event bindings like (click) and (input)",
            "Run in the component's context",
            "Should remain simple and fast"
          ]
        },
        {
          "heading": "Using $event",
          "points": [
            "$event represents the native DOM event",
            "Use $any($event.target).value to access input values",
            "Helps bypass strict TypeScript typing when needed"
          ]
        },
        {
          "heading": "Basic Examples",
          "example": {
            "code": "<button (click)=\"count = count + 1\">Add</button>\n<input (input)=\"text = $any($event.target).value\">"
          }
        },
        {
          "heading": "Full Working Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <button (click)=\"count = count + 1\">Increment</button>\n    <input placeholder=\"Type\" (input)=\"text = $any($event.target).value\" [value]=\"text\" />\n    <p>Count: {{ count }}</p>\n    <p>Text: {{ text || '(empty)' }}</p>\n  `\n})\nexport class App {\n  count = 0;\n  text = '';\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Key Concepts",
          "points": [
            "(click) binds an event listener",
            "$event provides access to the native event object",
            "Use $any() to avoid TypeScript casting issues",
            "Keep template logic minimal",
            "Move complex logic to component methods"
          ]
        },
        {
          "heading": "Exercise",
          "question": "How do you bind to a statement (call a method) from a template?",
          "options": [
            "(event)=\"handler()\"",
            "[event]=\"handler()\"",
            "{{ handler() }}"
          ],
          "correct_answer": "(event)=\"handler()\""
        }
      ]
    },

    "angular-template-alias-as": {
      "title": "Angular Templates: Alias with as in *ngIf",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "The `as` keyword in *ngIf allows you to create a local alias for the evaluated expression.",
            "It helps avoid repeating the same expression multiple times in a template.",
            "It improves readability and keeps templates clean."
          ]
        },
        {
          "heading": "What is alias with as in *ngIf?",
          "points": [
            "Creates a local alias for the truthy value of an expression",
            "Syntax: *ngIf=\"expression as alias\"",
            "The alias is only available inside the template block",
            "Commonly used with else templates"
          ]
        },
        {
          "heading": "When to Use Alias with as",
          "points": [
            "When the same expression is used multiple times",
            "When working with optional or async data",
            "When using else blocks that also require the value",
            "To improve readability and reduce repetition"
          ]
        },
        {
          "heading": "Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <button (click)=\"toggle()\">Toggle user</button>\n    <p *ngIf=\"user as u; else empty\">Hello {{ u.name }}!</p>\n    <ng-template #empty>No user</ng-template>\n  `\n})\nexport class App {\n  user: { name: string } | null = { name: 'Ada' };\n\n  toggle() {\n    this.user = this.user ? null : { name: 'Ada' };\n  }\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Example Explained",
          "points": [
            "*ngIf=\"user as u\": creates a local alias `u` for `user`",
            "u can be used inside the template instead of repeating user",
            "else empty renders the fallback template when user is null",
            "toggle() switches between null and an object"
          ]
        },
        {
          "heading": "Key Notes",
          "points": [
            "Alias exists only inside the template block",
            "Improves readability and avoids duplicate expressions",
            "Commonly used with *ngIf and *ngFor",
            "Works well with async or optional data"
          ]
        },
        {
          "heading": "Exercise",
          "question": "What does 'as' do in *ngIf / @if aliasing?",
          "options": [
            "Renames the component",
            "Creates a local alias for the value",
            "Imports a module"
          ],
          "correct_answer": "Creates a local alias for the value"
        }
      ]
    },
    "angular-template-attribute-binding": {
      "title": "Angular Templates: Attribute Binding with attr.",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "Attribute binding lets you bind values to HTML attributes using the attr. prefix.",
            "It is used when an attribute does not have a corresponding DOM property."
          ]
        },
        {
          "heading": "What is Attribute Binding?",
          "points": [
            "Uses [attr.name] syntax",
            "Used for HTML attributes such as aria-*, colspan, role",
            "Different from property binding",
            "Commonly used for accessibility attributes"
          ]
        },
        {
          "heading": "When to Use Attribute Binding",
          "points": [
            "When no DOM property exists",
            "For ARIA attributes",
            "For table attributes like colspan or rowspan",
            "When standard property binding does not work"
          ]
        },
        {
          "heading": "Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Attribute binding (attr.)</h3>\n    <button [attr.aria-label]=\"label\" (click)=\"toggle()\">Toggle label</button>\n    <table border=\"1\" style=\"margin-top:8px\">\n      <tr><th>A</th><th>B</th><th>C</th></tr>\n      <tr>\n        <td [attr.colspan]=\"wide ? 2 : 1\">Row 1</td>\n        <td>Cell</td>\n        <td>Cell</td>\n      </tr>\n    </table>\n  `\n})\nexport class App {\n  wide = true;\n  get label() {\n    return this.wide ? 'Table is wide' : 'Table is narrow';\n  }\n  toggle() {\n    this.wide = !this.wide;\n  }\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Example Explained",
          "points": [
            "[attr.aria-label] binds an accessibility attribute",
            "[attr.colspan] dynamically sets table column span",
            "attr. is used when no DOM property exists",
            "Getter recalculates label dynamically",
            "toggle() updates both label and layout"
          ]
        },
        {
          "heading": "Key Notes",
          "points": [
            "Use property binding when a DOM property exists",
            "Use attr. only for true HTML attributes",
            "Useful for accessibility and table layouts"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which syntax binds to an HTML attribute (not a DOM property)?",
          "options": ["[attr.role]", "[role]", "(role)"],
          "correct_answer": "[attr.role]"
        }
      ]
    },

    "angular-template-trackby": {
      "title": "Angular Templates: TrackBy with *ngFor",
      "sections": [
        {
          "heading": "Introduction",
          "paragraphs": [
            "TrackBy helps Angular efficiently render lists by identifying items with a unique key.",
            "It improves performance by preventing unnecessary DOM re-creation."
          ]
        },
        {
          "heading": "What is TrackBy?",
          "points": [
            "Defines how Angular tracks items in a list",
            "Helps reuse existing DOM elements",
            "Prevents unnecessary re-rendering",
            "Uses a unique identifier for each item"
          ]
        },
        {
          "heading": "When to Use TrackBy",
          "points": [
            "When lists are large",
            "When items are reordered, added, or removed",
            "When performance matters",
            "When items have stable IDs"
          ]
        },
        {
          "heading": "Example",
          "example": {
            "file": "main.ts",
            "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\ntype Item = { id: number; name: string };\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <button (click)=\"shuffle()\">Shuffle</button>\n    <ul>\n      <li *ngFor=\"let it of items; trackBy: trackById\">\n        {{ it.id }} - {{ it.name }}\n      </li>\n    </ul>\n  `\n})\nexport class App {\n  items: Item[] = [\n    { id: 1, name: 'Alpha' },\n    { id: 2, name: 'Beta' },\n    { id: 3, name: 'Gamma' }\n  ];\n\n  shuffle() {\n    this.items = [...this.items].reverse();\n  }\n\n  trackById(index: number, item: Item) {\n    return item.id;\n  }\n}\n\nbootstrapApplication(App);"
          }
        },
        {
          "heading": "Example Explained",
          "points": [
            "*ngFor uses trackById to identify items",
            "trackById returns a stable unique ID",
            "Angular reuses DOM nodes instead of recreating them",
            "Reversing the list keeps elements efficient"
          ]
        },
        {
          "heading": "Key Benefits",
          "points": [
            "Improves rendering performance",
            "Prevents unnecessary DOM updates",
            "Ideal for dynamic lists",
            "Recommended for large datasets"
          ]
        },
        {
          "heading": "Exercise",
          "question": "What is the benefit of using trackBy with list rendering?",
          "options": [
            "Improves rendering performance by tracking item identity",
            "Automatically sorts the list",
            "Prevents change detection"
          ],
          "correct_answer": "Improves rendering performance by tracking item identity"
        }
      ]
    },
    "angular-components": {
      "title": "Angular Components",
      "sections": [
        {
          "heading": "Overview",
          "description": "Components are the building blocks of Angular applications. Each component controls a view (HTML template) and its behavior."
        },
        {
          "heading": "Component Essentials",
          "points": [
            "Reusable UI building blocks",
            "@Component decorator defines selector, template, and styles",
            "Selectors are used as HTML tags",
            "Supports standalone components",
            "Communicates using @Input() and @Output()",
            "Supports content projection with <ng-content>"
          ]
        },
        {
          "heading": "Component Anatomy",
          "code": {
            "language": "ts",
            "content": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'hello-comp',\n  standalone: true,\n  styles: [`:host { display: block; }`],\n  template: `<p>Hello!</p>`\n})\nexport class HelloComponent {}"
          }
        },
        {
          "heading": "Component Input (@Input)",
          "description": "Pass data from parent to child components.",
          "example": {
            "child": "hello-comp",
            "binding": "[name]=\"user\"",
            "note": "Data flows one-way from parent to child"
          }
        },
        {
          "heading": "Component Output (@Output)",
          "description": "Emit events from child to parent using EventEmitter.",
          "example": {
            "output": "@Output() clicked = new EventEmitter<number>();",
            "listener": "(clicked)=\"onChildClicked($event)\""
          }
        },
        {
          "heading": "Content Projection",
          "description": "Allows a parent to project content into a child component using <ng-content>.",
          "features": [
            "Supports named slots using select",
            "Useful for layout components",
            "Keeps components reusable"
          ]
        },
        {
          "heading": "Lifecycle Hooks",
          "hooks": [
            "ngOnInit – initialization logic",
            "ngOnDestroy – cleanup logic",
            "ngOnChanges – input change tracking",
            "ngAfterViewInit – view initialization"
          ]
        },
        {
          "heading": "Best Practices",
          "points": [
            "Keep components small and focused",
            "Avoid mutating @Input() values",
            "Use services for business logic",
            "Prefer standalone components",
            "Use outputs for communication"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which decorator turns a class into an Angular component?",
          "options": ["@Directive", "@Component", "@Injectable"],
          "correct_answer": "@Component"
        }
      ]
    },

    "angular-data-binding": {
      "title": "Angular Data Binding",
      "description": "Data binding connects a component's state to the template and keeps the UI in sync with data.",
      "sections": [
        {
          "heading": "Data Binding Essentials",
          "points": [
            "Connect component state and template markup",
            "Use interpolation for text",
            "Use property binding for DOM properties",
            "Use event binding for user actions",
            "Use two-way binding for form inputs",
            "Bind attributes with [attr.*]",
            "Bind classes and styles with [class.*] and [style.*]"
          ],
          "syntax": [
            "{{ value }}",
            "[prop]=\"value\"",
            "(event)=\"handler($event)\"",
            "[(ngModel)]=\"value\""
          ]
        },
        {
          "heading": "Basic Data Binding",
          "types": ["Interpolation", "Property Binding", "Event Binding"],
          "examples": [
            "{{ name }}",
            "[value]=\"name\"",
            "(input)=\"name = $any($event.target).value\""
          ]
        },
        {
          "heading": "Example: Basic Binding",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Data Binding</h3>\n    <input [value]=\"name\" (input)=\"name = $any($event.target).value\">\n    <p>Hello {{ name }}!</p>\n    <button (click)=\"count = count + 1\">Clicked {{ count }} times</button>\n    <button [disabled]=\"isDisabled\">Can't click me</button>\n  `\n})\nexport class App {\n  name = 'Angular';\n  count = 0;\n  isDisabled = true;\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Two-way Binding",
          "description": "Synchronizes data between the component and template.",
          "notes": [
            "Uses [(ngModel)]",
            "Requires FormsModule",
            "Equivalent to [value] + (input)"
          ],
          "example": "<input [(ngModel)]=\"name\">"
        },
        {
          "heading": "Two-way Binding Example",
          "code": "import { Component } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [FormsModule],\n  template: `\n    <input [(ngModel)]=\"name\">\n    <p>Hello {{ name }}</p>\n  `\n})\nexport class App {\n  name = 'Angular';\n}"
        },
        {
          "heading": "Attribute Binding",
          "description": "Used when no DOM property exists.",
          "syntax": [
            "[attr.colspan]=\"span\"",
            "[class.active]=\"isActive\"",
            "[style.color]=\"color\""
          ]
        },
        {
          "heading": "Attribute Binding Example",
          "code": "<table [attr.title]=\"title\">\n  <tr>\n    <td [attr.colspan]=\"span\">Data</td>\n  </tr>\n</table>"
        },
        {
          "heading": "Important Notes",
          "points": [
            "Avoid heavy logic in templates",
            "Do not mutate state inside bindings",
            "Use property binding when available",
            "Use [attr.*] only when needed",
            "ngModel requires FormsModule"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which binding syntax sets a DOM/property value from the component?",
          "options": ["[prop]", "{{ }}", "(event)"],
          "answer": "[prop]"
        }
      ]
    },

    "angular-directives": {
      "title": "Angular Directives",
      "description": "Directives add behavior to existing elements and components.",
      "sections": [
        {
          "heading": "Directive Essentials",
          "points": [
            "Directives add behavior to elements",
            "Structural directives add or remove DOM elements",
            "Attribute directives modify appearance or behavior",
            "Star (*) syntax expands to <ng-template>",
            "Inputs can be aliased using @Input('alias')"
          ],
          "examples": [
            "*ngIf=\"condition\"",
            "*ngFor=\"let item of items\"",
            "@Directive({ selector: '[w3Highlight]' })",
            "<div w3Highlight></div>"
          ]
        },
        {
          "heading": "Basic Directives",
          "description": "Angular provides built-in structural directives.",
          "directives": [
            {
              "name": "*ngIf",
              "purpose": "Conditionally adds or removes elements"
            },
            {
              "name": "*ngFor",
              "purpose": "Repeats an element for each item in a list"
            }
          ],
          "example": "<p *ngIf=\"items.length > 0\">We have {{ items.length }} items</p>\n<li *ngFor=\"let item of items\">{{ item }}</li>"
        },
        {
          "heading": "Basic Directives Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <h3>Directives</h3>\n    <p *ngIf=\"items.length > 0\">We have {{ items.length }} items</p>\n    <ul>\n      <li *ngFor=\"let item of items\">{{ item }}</li>\n    </ul>\n    <button (click)=\"toggle()\">Toggle Items</button>\n  `\n})\nexport class App {\n  show = true;\n  get items() {\n    return this.show ? ['Angular', 'Components', 'Directives'] : [];\n  }\n  toggle() { this.show = !this.show; }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "ngIf with else",
          "description": "Use else or then/else blocks for conditional rendering.",
          "example": "<ng-container *ngIf=\"loggedIn; else loggedOut\"></ng-container>\n<ng-template #loggedOut>...</ng-template>"
        },
        {
          "heading": "ngIf then / else Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <button (click)=\"loggedIn = !loggedIn\">\n      {{ loggedIn ? 'Log out' : 'Log in' }}\n    </button>\n\n    <ng-container *ngIf=\"loggedIn; else loggedOut\">\n      <p>Welcome back, {{ user }}!</p>\n    </ng-container>\n\n    <ng-template #loggedOut>\n      <p>Please log in.</p>\n    </ng-template>\n  `\n})\nexport class App {\n  loggedIn = false;\n  user = 'Angular User';\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Attribute Directive",
          "description": "Changes appearance or behavior without altering DOM structure.",
          "features": [
            "@Directive decorator",
            "@HostBinding for DOM properties",
            "@HostListener for events"
          ],
          "example": "<div [w3Highlight]=\"'lightyellow'\">Hover me</div>"
        },
        {
          "heading": "Custom Attribute Directive Example",
          "code": "import { Directive, Input, HostBinding, HostListener } from '@angular/core';\n\n@Directive({\n  selector: '[w3Highlight]',\n  standalone: true\n})\nexport class HighlightDirective {\n  @Input('w3Highlight') highlightColor = 'lightyellow';\n  @HostBinding('style.backgroundColor') bg = '';\n\n  @HostListener('mouseenter') onEnter() {\n    this.bg = this.highlightColor;\n  }\n\n  @HostListener('mouseleave') onLeave() {\n    this.bg = '';\n  }\n}"
        },
        {
          "heading": "Important Notes",
          "points": [
            "Import CommonModule to use built-in directives",
            "Only one structural directive per element",
            "Use <ng-container> to avoid extra DOM nodes",
            "Avoid heavy logic inside templates",
            "Use trackBy with *ngFor for large lists"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which directive repeats a block for each item in a list?",
          "options": ["*ngFor", "*ngIf", "[ngClass]"],
          "answer": "*ngFor"
        }
      ]
    },

    "angular-events": {
      "title": "Angular Events",
      "description": "Events allow templates to react to user interactions such as clicks, typing, and key presses.",
      "sections": [
        {
          "heading": "Event Binding Essentials",
          "points": [
            "Use (event) syntax to bind events",
            "$event provides access to the native DOM event",
            "Supports common DOM events like click, input, keyup",
            "Supports key filtering like keyup.enter",
            "Events bubble unless stopped explicitly"
          ],
          "examples": [
            "(click)=\"onClick()\"",
            "(input)=\"onInput($event)\"",
            "(keyup.enter)=\"submit()\""
          ]
        },
        {
          "heading": "Basic Events",
          "description": "Handle user actions and update component state.",
          "example": "<button (click)=\"increment()\">Click me</button>\n<input (input)=\"onInput($event)\">"
        },
        {
          "heading": "Basic Event Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Events</h3>\n    <p>Count: {{ count }}</p>\n    <button (click)=\"increment()\">Click me</button>\n\n    <div style=\"margin-top:12px\">\n      <input (input)=\"onInput($event)\" (keyup)=\"lastKey = $any($event).key\">\n      <p>Value: {{ value }}</p>\n      <p>Last key: {{ lastKey }}</p>\n    </div>\n  `\n})\nexport class App {\n  count = 0;\n  value = '';\n  lastKey = '';\n\n  increment() { this.count++; }\n  onInput(e: Event) {\n    this.value = (e.target as HTMLInputElement).value;\n  }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Event Filtering",
          "description": "Use key aliases to trigger handlers only for specific keys.",
          "example": "(keyup.enter)=\"add()\""
        },
        {
          "heading": "Event Filtering Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <input (keyup.enter)=\"add()\" (keyup)=\"lastKey = $any($event).key\">\n    <button (click)=\"add()\">Add</button>\n    <p>Last key: {{ lastKey }}</p>\n  `\n})\nexport class App {\n  lastKey = '';\n  add() { console.log('Item added'); }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Debounced Input",
          "description": "Delay execution to reduce frequent updates during typing.",
          "example": "Use setTimeout or RxJS debounceTime"
        },
        {
          "heading": "Debounce Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <input (input)=\"onInput($event)\">\n    <p>Immediate: {{ immediate }}</p>\n    <p>Debounced: {{ debounced }}</p>\n  `\n})\nexport class App {\n  immediate = '';\n  debounced = '';\n  private handle: any;\n\n  onInput(e: Event) {\n    const v = (e.target as HTMLInputElement).value;\n    this.immediate = v;\n    clearTimeout(this.handle);\n    this.handle = setTimeout(() => this.debounced = v, 400);\n  }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Important Notes",
          "points": [
            "Use (event) for event binding",
            "Use $event to access native event object",
            "Use key aliases instead of manual key checks",
            "Avoid heavy logic in event handlers",
            "Prefer immutable updates"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which syntax binds to a DOM event in Angular?",
          "options": ["{{ }}", "(event)", "[prop]"],
          "answer": "(event)"
        }
      ]
    },

    "angular-conditional": {
      "title": "Angular Conditional",
      "description": "Conditional rendering shows or hides parts of the template based on application state.",
      "sections": [
        {
          "heading": "Conditional Rendering Essentials",
          "points": [
            "Use @if / @else / @else if for conditional logic",
            "Use @switch to render one of multiple views",
            "Signals drive template conditions",
            "@if removes elements from the DOM",
            "[hidden] hides elements without removing them",
            "*ngIf and ngSwitch are legacy but still supported"
          ],
          "syntax": [
            "@if (condition) { ... } @else { ... }",
            "@switch (value) { @case('x') { } @default { } }",
            "<div [hidden]=\"!isVisible\"></div>"
          ]
        },
        {
          "heading": "Basic Conditional Rendering",
          "description": "Render content conditionally using signals and @if blocks.",
          "example": "Use @if and @else with signals to toggle visibility."
        },
        {
          "heading": "Basic Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, signal } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Conditional Rendering</h3>\n    <button (click)=\"show.set(!show())\">Toggle</button>\n    @if (show()) { <p>Now you see me!</p> } @else { <p>Now I'm hidden.</p> }\n  `\n})\nexport class App {\n  show = signal(true);\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Explanation",
          "points": [
            "@if(show()): Renders content when condition is true",
            "Signals are read by calling them (show())",
            "State updates trigger re-render automatically"
          ]
        },
        {
          "heading": "@switch Rendering",
          "description": "Render one block from multiple options.",
          "syntax": "@switch(value) { @case('x') { } @default { } }"
        },
        {
          "heading": "@switch Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, signal } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <select (change)=\"status.set($any($event.target).value)\">\n      <option value=\"loading\">loading</option>\n      <option value=\"success\">success</option>\n      <option value=\"error\">error</option>\n    </select>\n\n    @switch (status()) {\n      @case ('loading') { <p>Loading...</p> }\n      @case ('success') { <p>Success!</p> }\n      @case ('error') { <p style=\"color:red\">Error!</p> }\n      @default { <p>Unknown</p> }\n    }\n  `\n})\nexport class App {\n  status = signal('loading');\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Multi-State Conditional Rendering",
          "description": "Use @if / @else if / @else for multi-state UI logic."
        },
        {
          "heading": "Multi-State Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, signal } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <button (click)=\"startLoading()\">Load</button>\n    <button (click)=\"showError()\">Error</button>\n    <button (click)=\"reset()\">Reset</button>\n\n    @if (!loading() && !error()) {\n      <p>Content loaded successfully.</p>\n    } @else if (loading()) {\n      <p>Loading...</p>\n    } @else {\n      <p style=\"color:red\">Something went wrong.</p>\n    }\n  `\n})\nexport class App {\n  loading = signal(false);\n  error = signal(false);\n\n  startLoading() {\n    this.loading.set(true);\n    this.error.set(false);\n    setTimeout(() => this.loading.set(false), 800);\n  }\n\n  showError() {\n    this.error.set(true);\n    this.loading.set(false);\n  }\n\n  reset() {\n    this.loading.set(false);\n    this.error.set(false);\n  }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Prefer @if over [hidden] when removing elements",
            "Keep conditions simple",
            "Use signals instead of functions",
            "Always include @default in @switch",
            "Avoid complex logic inside templates"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which control flow syntax conditionally adds or removes elements from the DOM?",
          "options": ["@if", "@for", "[hidden]"],
          "answer": "@if"
        }
      ]
    },
    "angular-lists": {
      "title": "Angular Lists",
      "description": "Lists display collections of items in the template using Angular control flow.",
      "sections": [
        {
          "heading": "List Rendering Essentials",
          "points": [
            "Use @for to loop through collections",
            "Use track for stable identity and better performance",
            "Use @empty to render fallback content",
            "Store list data in signals",
            "Update lists immutably using set() or update()",
            "Use computed() for derived or filtered lists"
          ]
        },
        {
          "heading": "Basic List Rendering",
          "description": "Render lists using @for and expose the index with $index.",
          "syntax": [
            "@for (item of items(); let i = $index; track item) { ... }",
            "@empty { ... }"
          ]
        },
        {
          "heading": "Basic Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, signal } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Lists</h3>\n    <ul>\n      @for (item of items(); let i = $index; track item) {\n        <li>{{ i + 1 }}. {{ item }}</li>\n      } @empty {\n        <li>No items</li>\n      }\n    </ul>\n    <button (click)=\"add()\">Add</button>\n    <button (click)=\"clear()\">Clear</button>\n    <button (click)=\"reset()\">Reset</button>\n  `\n})\nexport class App {\n  items = signal(['Angular', 'React', 'Vue']);\n\n  add() { this.items.update(arr => [...arr, 'Svelte']); }\n  clear() { this.items.set([]); }\n  reset() { this.items.set(['Angular', 'React', 'Vue']); }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Explanation",
          "points": [
            "@for loops over signal data",
            "$index provides the zero-based index",
            "@empty renders when list is empty",
            "Signals require immutable updates"
          ]
        },
        {
          "heading": "Tracking Items (track)",
          "description": "Use track to preserve DOM elements when items change.",
          "syntax": "@for (item of items(); track item.id) { ... }"
        },
        {
          "heading": "Track Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, signal } from '@angular/core';\n\ntype Item = { id: number; name: string };\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Tracked List</h3>\n    <ul>\n      @for (it of items(); let i = $index; track it.id) {\n        <li>{{ i + 1 }}. {{ it.name }}</li>\n      }\n    </ul>\n    <button (click)=\"renameFirst()\">Rename</button>\n    <button (click)=\"shuffle()\">Shuffle</button>\n    <button (click)=\"add()\">Add</button>\n  `\n})\nexport class App {\n  items = signal([\n    { id: 1, name: 'Angular' },\n    { id: 2, name: 'React' },\n    { id: 3, name: 'Vue' }\n  ]);\n\n  nextId = 4;\n\n  renameFirst() {\n    this.items.update(arr =>\n      arr.map((it, i) => i === 0 ? { ...it, name: it.name + ' *' } : it)\n    );\n  }\n\n  shuffle() {\n    this.items.update(arr => {\n      const copy = [...arr];\n      for (let i = copy.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [copy[i], copy[j]] = [copy[j], copy[i]];\n      }\n      return copy;\n    });\n  }\n\n  add() {\n    this.items.update(arr => [...arr, { id: this.nextId++, name: 'New Item' }]);\n  }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Always use track for large or dynamic lists",
            "Avoid mutating arrays directly",
            "Use signals for reactive updates",
            "Prefer derived lists using computed()",
            "Use @empty to handle empty states"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which directive is used to loop through a list in Angular?",
          "options": ["@for", "@if", "[hidden]"],
          "answer": "@for"
        }
      ]
    },

    "angular-forms": {
      "title": "Angular Forms",
      "description": "Forms allow users to enter and edit data in Angular applications.",
      "sections": [
        {
          "heading": "Forms Essentials",
          "points": [
            "Two types: Template-driven and Reactive forms",
            "Template-driven uses [(ngModel)]",
            "Reactive forms use FormGroup and FormControl",
            "FormsModule is required for template-driven forms",
            "ReactiveFormsModule is required for reactive forms"
          ]
        },
        {
          "heading": "Template-driven Forms",
          "description": "Simple and HTML-focused approach using ngModel.",
          "features": [
            "Easy to set up",
            "Uses [(ngModel)]",
            "Uses ngForm for validation state",
            "Best for simple forms"
          ]
        },
        {
          "heading": "Template-driven Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  template: `\n    <h3>Forms</h3>\n    <form #f=\"ngForm\" (ngSubmit)=\"onSubmit()\">\n      <label>\n        Name:\n        <input name=\"name\" [(ngModel)]=\"name\" placeholder=\"Enter your name\">\n      </label>\n      <button type=\"submit\">Submit</button>\n    </form>\n    <p>Value: {{ name }}</p>\n    <p *ngIf=\"submitted\">Submitted!</p>\n  `\n})\nexport class App {\n  name = '';\n  submitted = false;\n  onSubmit() { this.submitted = true; }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Explanation",
          "points": [
            "[(ngModel)] binds input value to component",
            "#f=\"ngForm\" exposes form state",
            "(ngSubmit) handles submit event",
            "Form validity is tracked automatically"
          ]
        },
        {
          "heading": "Form Controls",
          "elements": [
            "Text, Email, Number inputs",
            "Textarea",
            "Checkbox",
            "Radio buttons",
            "Select dropdown",
            "File input"
          ]
        },
        {
          "heading": "Common Bindings",
          "examples": [
            "<input [(ngModel)]=\"model.email\">",
            "<textarea [(ngModel)]=\"model.bio\"></textarea>",
            "<input type=\"checkbox\" [(ngModel)]=\"model.agree\">",
            "<input type=\"radio\" [value]=\"'red'\" [(ngModel)]=\"model.color\">",
            "<select [(ngModel)]=\"model.pet\"></select>"
          ]
        },
        {
          "heading": "Radio & Select with Objects",
          "notes": [
            "Use [ngValue] for non-string values",
            "Radio buttons share the same name",
            "Select supports object binding"
          ],
          "example": [
            "<input type=\"radio\" [ngValue]=\"1\" [(ngModel)]=\"size\">",
            "<option [ngValue]=\"{ id: 1, name: 'Cat' }\">Cat</option>"
          ]
        },
        {
          "heading": "Multiple Select",
          "example": "<select multiple [(ngModel)]=\"model.tags\">\n  <option [ngValue]=\"'news'\">News</option>\n  <option [ngValue]=\"'tech'\">Tech</option>\n</select>"
        },
        {
          "heading": "File Input",
          "notes": [
            "Do not use [(ngModel)] with files",
            "Use (change) event to read files"
          ],
          "example": "<input type=\"file\" (change)=\"onFiles($event)\">"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use template-driven forms for simple cases",
            "Use reactive forms for complex validation",
            "Always import FormsModule when using ngModel",
            "Use [ngValue] for objects",
            "Avoid two-way binding on file inputs"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which module is required for template-driven forms?",
          "options": ["FormsModule", "ReactiveFormsModule", "HttpClientModule"],
          "answer": "FormsModule"
        }
      ]
    },

    "angular-router": {
      "title": "Angular Router",
      "description": "The Angular Router maps URLs to views and enables navigation within a single-page application.",
      "sections": [
        {
          "heading": "Router Essentials",
          "points": [
            "Router maps URLs to components",
            "RouterOutlet renders the active route",
            "routerLink navigates without page reload",
            "RouterLinkActive adds classes to active links",
            "Lazy loading and guards improve performance and security"
          ]
        },
        {
          "heading": "Basic Setup",
          "description": "Define routes and register them using provideRouter().",
          "code": "const routes = [\n  { path: '', component: Home },\n  { path: 'about', component: About }\n];\n\nbootstrapApplication(App, {\n  providers: [provideRouter(routes, withHashLocation())]\n});"
        },
        {
          "heading": "Router Template Usage",
          "code": "<a routerLink=\"/about\">About</a>\n<router-outlet></router-outlet>"
        },
        {
          "heading": "Router Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { provideRouter, RouterOutlet, RouterLink, withHashLocation } from '@angular/router';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [RouterOutlet, RouterLink],\n  template: `\n    <h3>Router</h3>\n    <nav>\n      <a routerLink=\"/\">Home</a> |\n      <a routerLink=\"/about\">About</a>\n    </nav>\n    <router-outlet></router-outlet>\n  `\n})\nexport class App {}\n\n@Component({ standalone: true, template: `<p>Home works!</p>` })\nexport class Home {}\n\n@Component({ standalone: true, template: `<p>About works!</p>` })\nexport class About {}\n\nconst routes = [\n  { path: '', component: Home },\n  { path: 'about', component: About }\n];\n\nbootstrapApplication(App, {\n  providers: [provideRouter(routes, withHashLocation())]\n});"
        },
        {
          "heading": "Explanation",
          "points": [
            "provideRouter() registers application routes",
            "RouterOutlet displays the active component",
            "routerLink enables SPA navigation",
            "withHashLocation() allows routing without server config"
          ]
        },
        {
          "heading": "Router Parameters",
          "description": "Route parameters allow passing values via the URL.",
          "example": {
            "route": "{ path: 'product/:id', component: Product }",
            "component": "this.id = this.route.snapshot.paramMap.get('id');"
          }
        },
        {
          "heading": "Router Params Example",
          "code": "import { Component, OnInit, inject } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\n\n@Component({\n  standalone: true,\n  template: `<p>Product ID: {{ id }}</p>`\n})\nexport class Product implements OnInit {\n  id = '';\n  private route = inject(ActivatedRoute);\n\n  ngOnInit() {\n    this.id = this.route.snapshot.paramMap.get('id') ?? '';\n  }\n}"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use routerLink instead of href",
            "Always define a default route",
            "Use withHashLocation for local testing",
            "Use route params for dynamic content",
            "Use lazy loading for large apps"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which directive displays the active routed component?",
          "options": ["routerLink", "RouterOutlet", "RouterLinkActive"],
          "answer": "RouterOutlet"
        }
      ]
    },

    "angular-services-di": {
      "title": "Angular Services & Dependency Injection",
      "description": "Services hold reusable logic and state. Dependency Injection (DI) supplies service instances where needed.",
      "sections": [
        {
          "heading": "Services & DI Essentials",
          "points": [
            "Services contain reusable logic and shared state",
            "Dependency Injection provides service instances automatically",
            "Use providedIn: 'root' for singleton services",
            "Provide services at component level for isolated instances",
            "Common use cases: data fetching, caching, business logic"
          ]
        },
        {
          "heading": "Basic Service Example",
          "code": "import { Injectable } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class CounterService {\n  value = 0;\n  inc() { this.value++; }\n}"
        },
        {
          "heading": "Injecting a Service",
          "code": "constructor(public counter: CounterService) {}",
          "explanation": [
            "Angular injects the service automatically",
            "The instance is shared across the application",
            "Public injection allows template access"
          ]
        },
        {
          "heading": "Service Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, Injectable } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class CounterService {\n  value = 0;\n  inc() { this.value++; }\n  dec() { this.value--; }\n  reset() { this.value = 0; }\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Services</h3>\n    <p>Counter: {{ counter.value }}</p>\n    <button (click)=\"counter.inc()\">+</button>\n    <button (click)=\"counter.dec()\">-</button>\n    <button (click)=\"counter.reset()\">Reset</button>\n  `\n})\nexport class App {\n  constructor(public counter: CounterService) {}\n}"
        },
        {
          "heading": "Explanation",
          "points": [
            "@Injectable makes the class available for DI",
            "providedIn: 'root' creates a singleton service",
            "Injected services are shared across components",
            "Service methods control shared state"
          ]
        },
        {
          "heading": "Shared Service Across Components",
          "description": "Multiple components share the same service instance when provided in root.",
          "example": {
            "components": ["CounterA", "CounterB"],
            "behavior": "Both components modify the same service state"
          }
        },
        {
          "heading": "Shared Service Example",
          "code": "import { Component, Injectable } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class CounterService {\n  value = 0;\n  inc() { this.value++; }\n  dec() { this.value--; }\n}\n\n@Component({\n  selector: 'counter-a',\n  standalone: true,\n  template: `\n    <h4>Counter A</h4>\n    <p>{{ counter.value }}</p>\n    <button (click)=\"counter.inc()\">+</button>\n  `\n})\nexport class CounterA {\n  constructor(public counter: CounterService) {}\n}\n\n@Component({\n  selector: 'counter-b',\n  standalone: true,\n  template: `\n    <h4>Counter B</h4>\n    <p>{{ counter.value }}</p>\n    <button (click)=\"counter.dec()\">-</button>\n  `\n})\nexport class CounterB {\n  constructor(public counter: CounterService) {}\n}"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use services for business logic, not components",
            "Keep services lightweight and focused",
            "Avoid large shared mutable state",
            "Use providedIn: 'root' unless isolation is required",
            "Use inject() in functional contexts like guards"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which decorator makes a class injectable in Angular?",
          "options": ["@Component", "@Injectable", "@NgModule"],
          "answer": "@Injectable"
        }
      ]
    },

    "angular-pipes": {
      "title": "Angular Pipes",
      "description": "Pipes format values in Angular templates using the | operator. They are used only for presentation.",
      "sections": [
        {
          "heading": "Pipes Essentials",
          "points": [
            "Pipes transform data for display",
            "Applied using the | symbol",
            "Do not change original data",
            "Pure by default",
            "Async pipe handles Observables automatically"
          ]
        },
        {
          "heading": "Common Built-in Pipes",
          "examples": [
            "{{ title | uppercase }}",
            "{{ price | currency:'USD' }}",
            "{{ today | date:'short' }}",
            "{{ percent | percent:'1.0-2' }}"
          ],
          "description": "Angular provides pipes for strings, numbers, and dates."
        },
        {
          "heading": "Basic Pipe Example",
          "code": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <p>{{ title | uppercase }}</p>\n    <p>{{ price | currency:'USD' }}</p>\n    <p>{{ today | date:'mediumDate' }}</p>\n    <p>{{ percent | percent:'1.0-2' }}</p>\n  `\n})\nexport class App {\n  title = 'Angular';\n  price = 1234.5;\n  today = new Date();\n  percent = 0.3495;\n}"
        },
        {
          "heading": "Async Pipe",
          "description": "Automatically subscribes to Observables and unsubscribes when the view is destroyed.",
          "example": "<p>{{ time$ | async | date:'mediumTime' }}</p>",
          "notes": [
            "Avoids manual subscription handling",
            "Works with Observables and Promises",
            "Use once per stream to avoid multiple subscriptions"
          ]
        },
        {
          "heading": "Async Pipe Example",
          "code": "import { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { interval, of } from 'rxjs';\nimport { map, delay } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  template: `\n    <p>Time: {{ time$ | async | date:'mediumTime' }}</p>\n\n    <ng-container *ngIf=\"users$ | async as users; else loading\">\n      <ul>\n        <li *ngFor=\"let u of users\">{{ u.name }}</li>\n      </ul>\n    </ng-container>\n\n    <ng-template #loading>Loading...</ng-template>\n  `\n})\nexport class App {\n  time$ = interval(1000).pipe(map(() => new Date()));\n  users$ = of([{ name: 'Alice' }, { name: 'Bob' }]).pipe(delay(1000));\n}"
        },
        {
          "heading": "Custom Pipe",
          "description": "Create reusable formatters using @Pipe.",
          "code": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({ name: 'titlecase2', standalone: true })\nexport class TitleCase2Pipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) return '';\n    return value\n      .split(' ')\n      .map(w => w[0].toUpperCase() + w.slice(1).toLowerCase())\n      .join(' ');\n  }\n}"
        },
        {
          "heading": "Using Custom Pipe",
          "code": "<p>{{ text | titlecase2 }}</p>",
          "notes": [
            "Must be imported in component",
            "Pure by default",
            "Should not perform heavy logic"
          ]
        },
        {
          "heading": "Best Practices",
          "points": [
            "Keep pipes simple and fast",
            "Avoid business logic inside pipes",
            "Prefer pure pipes",
            "Use async pipe instead of manual subscriptions",
            "Handle null/undefined safely"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which symbol is used to apply a pipe in Angular?",
          "options": ["|", "@", ":"],
          "answer": "|"
        }
      ]
    },

    "angular-http-client": {
      "title": "Angular Http Client",
      "description": "HttpClient allows Angular applications to communicate with backend APIs using HTTP methods.",
      "sections": [
        {
          "heading": "HTTP Essentials",
          "points": [
            "HttpClient is used to fetch and send data",
            "All HTTP methods return Observables",
            "Use loading and error states for good UX",
            "Register HttpClient using provideHttpClient()",
            "Avoid blocking UI during requests"
          ]
        },
        {
          "heading": "Setup",
          "code": "import { provideHttpClient } from '@angular/common/http';\n\nbootstrapApplication(App, {\n  providers: [provideHttpClient()]\n});",
          "notes": [
            "Use provideHttpClient() instead of HttpClientModule",
            "Required for standalone Angular apps"
          ]
        },
        {
          "heading": "GET Request",
          "description": "Fetch data from an API and handle loading and error states.",
          "code": "import { Component, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <button (click)=\"load()\">Load Users</button>\n    <p *ngIf=\"loading\">Loading...</p>\n    <p *ngIf=\"error\" style=\"color:red\">{{ error }}</p>\n    <ul>\n      <li *ngFor=\"let u of users\">{{ u.name }}</li>\n    </ul>\n  `\n})\nexport class App {\n  http = inject(HttpClient);\n  users: any[] = [];\n  loading = false;\n  error = '';\n\n  load() {\n    this.loading = true;\n    this.http.get<any[]>('https://jsonplaceholder.typicode.com/users')\n      .subscribe({\n        next: data => {\n          this.users = data;\n          this.loading = false;\n        },\n        error: () => {\n          this.error = 'Failed to load users';\n          this.loading = false;\n        }\n      });\n  }\n}"
        },
        {
          "heading": "GET Request Notes",
          "points": [
            "http.get<T>() returns an Observable",
            "subscribe() executes the request",
            "Always handle error and loading states",
            "Use typed responses when possible"
          ]
        },
        {
          "heading": "POST Request",
          "description": "Send data to a server using POST.",
          "code": "this.http.post<Post>('https://api.example.com/posts', {\n  title: 'Hello',\n  body: 'Angular HTTP'\n}).subscribe({\n  next: res => this.result = res,\n  error: () => this.error = 'Failed to create'\n});"
        },
        {
          "heading": "POST Example",
          "code": "import { Component, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <button (click)=\"createPost()\">Create Post</button>\n    <p *ngIf=\"loading\">Sending...</p>\n    <p *ngIf=\"error\">{{ error }}</p>\n    <p *ngIf=\"result\">Created ID: {{ result.id }}</p>\n  `\n})\nexport class App {\n  http = inject(HttpClient);\n  loading = false;\n  error = '';\n  result: any;\n\n  createPost() {\n    this.loading = true;\n    this.http.post('https://jsonplaceholder.typicode.com/posts', {\n      title: 'Angular',\n      body: 'HttpClient example'\n    }).subscribe({\n      next: r => { this.result = r; this.loading = false; },\n      error: () => { this.error = 'Failed'; this.loading = false; }\n    });\n  }\n}"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use services to encapsulate HTTP logic",
            "Always handle errors",
            "Use interceptors for auth/logging",
            "Avoid multiple subscriptions",
            "Disable UI while loading",
            "Prefer async pipe where possible"
          ]
        },
        {
          "heading": "Common Issues",
          "points": [
            "CORS errors occur when API disallows browser requests",
            "Always use HTTPS APIs",
            "Do not interpolate untrusted user input into URLs",
            "Use HttpParams for query strings"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which function enables HttpClient in Angular standalone apps?",
          "options": ["provideHttpClient()", "HttpClientModule()", "useHttp()"],
          "answer": "provideHttpClient()"
        }
      ]
    },
    "angular-lifecycle": {
      "title": "Angular Lifecycle Hooks",
      "description": "Lifecycle hooks are methods Angular calls at key moments during a component's life such as creation, updates, rendering, and destruction.",
      "sections": [
        {
          "heading": "Lifecycle Essentials",
          "points": [
            "Lifecycle hooks let you run code at specific moments",
            "ngOnInit runs after inputs are set",
            "ngOnChanges reacts to input changes",
            "ngAfterViewInit runs after the view loads",
            "ngOnDestroy cleans up resources"
          ]
        },
        {
          "heading": "Common Lifecycle Hooks",
          "hooks": [
            {
              "name": "ngOnInit",
              "purpose": "Runs once after inputs are initialized"
            },
            {
              "name": "ngOnChanges",
              "purpose": "Runs when @Input values change"
            },
            {
              "name": "ngAfterViewInit",
              "purpose": "Runs after the component view is fully initialized"
            },
            {
              "name": "ngOnDestroy",
              "purpose": "Runs before the component is destroyed"
            }
          ]
        },
        {
          "heading": "Basic Example",
          "code": "import { Component, OnInit, OnDestroy, AfterViewInit, ViewChild, ElementRef } from '@angular/core';\n\n@Component({\n  selector: 'app-demo',\n  template: `<input #box />`\n})\nexport class DemoComponent implements OnInit, AfterViewInit, OnDestroy {\n  @ViewChild('box') box!: ElementRef<HTMLInputElement>;\n  intervalId: any;\n\n  ngOnInit() {\n    console.log('Initialized');\n  }\n\n  ngAfterViewInit() {\n    this.box.nativeElement.focus();\n  }\n\n  ngOnDestroy() {\n    clearInterval(this.intervalId);\n  }\n}"
        },
        {
          "heading": "Lifecycle with *ngIf",
          "description": "Toggling a component with *ngIf triggers creation and destruction.",
          "code": "export class ChildComponent implements OnInit, OnDestroy {\n  intervalId: any;\n\n  ngOnInit() {\n    this.intervalId = setInterval(() => {}, 1000);\n  }\n\n  ngOnDestroy() {\n    clearInterval(this.intervalId);\n  }\n}"
        },
        {
          "heading": "Input Change Detection",
          "description": "ngOnChanges runs when @Input values change.",
          "code": "ngOnChanges(changes: SimpleChanges) {\n  console.log(changes);\n}"
        },
        {
          "heading": "ViewChild Usage",
          "description": "Access DOM elements after view initialization.",
          "code": "@ViewChild('box') box!: ElementRef;\n\nngAfterViewInit() {\n  this.box.nativeElement.focus();\n}"
        },
        {
          "heading": "Cleanup Best Practices",
          "points": [
            "Clear intervals and timeouts",
            "Unsubscribe from Observables",
            "Remove event listeners",
            "Use async pipe when possible",
            "Avoid heavy logic in lifecycle hooks"
          ]
        },
        {
          "heading": "Common Mistakes",
          "points": [
            "Accessing DOM in constructor",
            "Forgetting to unsubscribe",
            "Mutating inputs instead of replacing",
            "Running heavy logic in ngOnChanges"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which lifecycle hook runs after the component view is fully initialized?",
          "options": ["ngOnInit", "ngAfterViewInit", "ngOnDestroy"],
          "answer": "ngAfterViewInit"
        }
      ]
    },

    "angular-styling": {
      "title": "Angular Styling",
      "description": "Styling in Angular uses class and style bindings along with component-scoped CSS to build maintainable and dynamic user interfaces.",
      "sections": [
        {
          "heading": "Styling Essentials",
          "points": [
            "Use [class.foo] and [ngClass] for class binding",
            "Use [style.prop] and [ngStyle] for inline styles",
            "Component styles are scoped by default",
            "Use CSS variables for theming",
            "Use :host and :host-context() for component-level styling"
          ]
        },
        {
          "heading": "Basic Styling",
          "description": "Apply dynamic classes and styles using Angular bindings.",
          "code": "<div\n  [class.highlight]=\"highlight\"\n  [ngClass]=\"{ big: big }\"\n  [style.color]=\"color\"\n  [style.borderColor]=\"color\">\n  Styled box\n</div>"
        },
        {
          "heading": "Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [CommonModule],\n  styles: [`\n    .box { padding: 12px; border: 2px solid #ccc; border-radius: 6px; }\n    .highlight { background: #fffa8b; }\n    .big { font-size: 24px; }\n  `],\n  template: `\n    <button (click)=\"toggleHighlight()\">Highlight</button>\n    <button (click)=\"toggleBig()\">Big</button>\n    <button (click)=\"setColor('crimson')\">Red</button>\n\n    <div class=\"box\"\n      [class.highlight]=\"highlight\"\n      [ngClass]=\"{ big: big }\"\n      [style.color]=\"color\">\n      Styled Box\n    </div>\n  `\n})\nexport class App {\n  highlight = false;\n  big = false;\n  color = 'royalblue';\n\n  toggleHighlight() { this.highlight = !this.highlight; }\n  toggleBig() { this.big = !this.big; }\n  setColor(c: string) { this.color = c; }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Dynamic Styling",
          "points": [
            "Use [ngClass] for multiple conditional classes",
            "Use [ngStyle] for dynamic inline styles",
            "Prefer CSS classes for complex styling",
            "Avoid mixing static class and ngClass on the same element"
          ]
        },
        {
          "heading": "ngClass and ngStyle Example",
          "code": "<div\n  [ngClass]=\"{ fancy: fancy, rounded: rounded }\"\n  [ngStyle]=\"{ color: color, padding: pad + 'px' }\">\n  Dynamic styles\n</div>"
        },
        {
          "heading": "Encapsulation & Host Styling",
          "points": [
            "Styles are scoped per component by default",
            "Use :host to style the component root",
            "Use :host-context() to respond to parent themes",
            "Avoid global CSS unless necessary"
          ]
        },
        {
          "heading": "Best Practices",
          "points": [
            "Prefer class bindings over inline styles",
            "Use boolean bindings instead of string booleans",
            "Keep style logic simple",
            "Use CSS variables for themes",
            "Import CommonModule for ngClass/ngStyle"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which binding is used to apply multiple CSS classes dynamically?",
          "options": ["[class.foo]", "[ngClass]", "[style]"],
          "answer": "[ngClass]"
        }
      ]
    },

    "angular-bootstrap": {
      "title": "Angular App Bootstrap",
      "description": "Bootstrap initializes the Angular app and registers providers such as Router and HttpClient for dependency injection and application-wide services.",
      "sections": [
        {
          "heading": "App Bootstrap Essentials",
          "points": [
            "Use bootstrapApplication() to start the app",
            "Register providers such as Router and HttpClient at bootstrap",
            "Providers define how dependencies are created",
            "Register providers at the smallest useful scope for performance",
            "Prefer standalone APIs over NgModules"
          ]
        },
        {
          "heading": "Basic Bootstrap Example",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { provideRouter } from '@angular/router';\nimport { provideHttpClient } from '@angular/common/http';\n\nbootstrapApplication(App, {\n  providers: [\n    provideRouter(routes),\n    provideHttpClient()\n  ]\n});"
        },
        {
          "heading": "Example: App Bootstrap with Router",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\nimport { Routes, provideRouter, RouterOutlet } from '@angular/router';\nimport { provideHttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'home-page',\n  standalone: true,\n  template: `<p>Home works</p>`\n})\nclass Home {}\n\nconst routes: Routes = [\n  { path: '', component: Home }\n];\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [RouterOutlet],\n  template: `<router-outlet></router-outlet>`\n})\nclass App {}\n\nbootstrapApplication(App, {\n  providers: [\n    provideRouter(routes),\n    provideHttpClient()\n  ]\n});"
        },
        {
          "heading": "Feature-Scoped Providers",
          "description": "Providers can be scoped to specific routes or features to reduce bundle size and improve performance.",
          "code": "const routes = [\n  {\n    path: 'admin',\n    providers: [provideHttpClient()],\n    loadComponent: () => import('./admin.component').then(m => m.AdminComponent)\n  }\n];\n\nbootstrapApplication(App, { providers: [provideRouter(routes)] });"
        },
        {
          "heading": "Feature Provider Benefits",
          "points": [
            "Reduces global memory usage",
            "Improves startup performance",
            "Keeps services isolated",
            "Allows lazy-loaded features",
            "Avoids unnecessary singletons"
          ]
        },
        {
          "heading": "HttpClient Setup",
          "points": [
            "Use provideHttpClient() instead of HttpClientModule",
            "Register once at the required scope",
            "Use interceptors for auth/logging",
            "Avoid duplicate registrations"
          ],
          "code": "import { provideHttpClient } from '@angular/common/http';\n\nbootstrapApplication(App, {\n  providers: [provideHttpClient()]\n});"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Keep root component minimal",
            "Use lazy loading whenever possible",
            "Scope providers carefully",
            "Avoid global services unless required",
            "Use standalone APIs"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which function starts an Angular app and configures dependency injection?",
          "options": [
            "bootstrapApplication",
            "provideRouter",
            "provideHttpClient"
          ],
          "answer": "bootstrapApplication"
        }
      ]
    },

    "angular-control-flow": {
      "title": "Angular Control Flow",
      "description": "Control flow directives (@if, @for, @switch) render conditional content, lists, and cases in Angular templates. They replace legacy *ngIf, *ngFor, and [ngSwitch] for new applications.",
      "sections": [
        {
          "heading": "Control Flow Essentials",
          "points": [
            "@if: Conditional rendering with optional else and else if blocks",
            "@for: Iterates over collections with track support",
            "@switch: Renders a matching case",
            "Preferred for Angular 17+ applications",
            "Legacy syntax (*ngIf, *ngFor, [ngSwitch]) still supported"
          ]
        },
        {
          "heading": "Syntax Examples",
          "code": "@if (score > 90) { <p>A</p> } @else if (score > 75) { <p>B</p> } @else { <p>C</p> }\n\n<ul>\n  @for (it of items; track it.id) { <li>{{ it.label }}</li> } @empty { <li>No items</li> }\n</ul>\n\n@switch (status) {\n  @case ('pending') { <p>Pending</p> }\n  @case ('done') { <p>Done</p> }\n  @default { <p>Unknown</p> }\n}"
        },
        {
          "heading": "Control Flow Basics",
          "points": [
            "Use @if for conditional rendering",
            "Use @for for loops with stable tracking",
            "Use @switch for multi-branch logic",
            "Prefer @for track for DOM efficiency"
          ]
        },
        {
          "heading": "Example",
          "description": "Toggle content and render lists using control flow directives.",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, signal } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Control Flow</h3>\n    <button (click)=\"show.set(!show())\">Toggle</button>\n    <button (click)=\"items.set([])\">Clear</button>\n    <button (click)=\"reset()\">Reset</button>\n\n    @if (show()) {\n      <p>Visible</p>\n    } @else {\n      <p>Hidden</p>\n    }\n\n    <ul>\n      @for (item of items(); track item) {\n        <li>{{ item }}</li>\n      } @empty {\n        <li>No items</li>\n      }\n    </ul>\n  `\n})\nexport class App {\n  show = signal(true);\n  items = signal(['One', 'Two', 'Three']);\n  reset() { this.items.set(['One', 'Two', 'Three']); }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Example Explained",
          "points": [
            "@if / @else toggles content visibility",
            "@for renders list items",
            "track item preserves DOM stability",
            "@empty displays fallback content",
            "Signals drive reactive updates"
          ]
        },
        {
          "heading": "Best Practices",
          "points": [
            "Always use track with @for for better performance",
            "Use signals to drive control flow",
            "Avoid heavy logic in templates",
            "Prefer @if/@for over legacy syntax",
            "Keep rendering logic simple and declarative"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which modern Angular syntax conditionally renders a block?",
          "options": ["@if", "*ngIf", "v-if"],
          "answer": "@if"
        }
      ]
    },

    "angular-signals": {
      "title": "Angular Signals",
      "description": "Signals provide reactive state management in Angular. Values are read by calling them, updated with set()/update(), derived with computed(), and side effects handled with effect().",
      "sections": [
        {
          "heading": "Signals Essentials",
          "points": [
            "signal(): Creates reactive state",
            "Read by calling the signal (e.g., count())",
            "computed(): Derives read-only values",
            "effect(): Runs side effects when dependencies change",
            "Signals replace many RxJS use cases for local state"
          ]
        },
        {
          "heading": "Basic Usage",
          "code": "import { signal, computed, effect } from '@angular/core';\n\nconst count = signal(0);\nconst double = computed(() => count() * 2);\neffect(() => console.log('count =', count()));\n\ncount.update(n => n + 1);"
        },
        {
          "heading": "Example",
          "description": "Using signal, computed, and effect together.",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, signal, computed, effect } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Signals</h3>\n    <p>Count: {{ count() }}</p>\n    <p>Double: {{ double() }}</p>\n    <button (click)=\"inc()\">Increment</button>\n  `\n})\nexport class App {\n  count = signal(0);\n  double = computed(() => this.count() * 2);\n\n  constructor() {\n    effect(() => console.log('count changed', this.count()));\n  }\n\n  inc() {\n    this.count.update(n => n + 1);\n  }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Example Explained",
          "points": [
            "signal(0): creates reactive state",
            "computed(): recalculates when dependencies change",
            "effect(): runs whenever dependencies update",
            "update(): safely updates state"
          ]
        },
        {
          "heading": "Derived Values & Effects",
          "description": "Computed values and effects allow reactive logic without manual subscriptions.",
          "code": "const a = signal(2);\nconst b = signal(3);\nconst sum = computed(() => a() + b());\n\neffect(() => console.log('sum =', sum()));"
        },
        {
          "heading": "RxJS Interoperability",
          "points": [
            "toSignal(): Convert Observable → Signal",
            "toObservable(): Convert Signal → Observable",
            "Always provide initialValue for toSignal()",
            "Useful when integrating with HTTP or streams"
          ],
          "code": "import { toSignal, toObservable } from '@angular/core';\nimport { interval } from 'rxjs';\n\nconst seconds$ = interval(1000);\nconst seconds = toSignal(seconds$, { initialValue: 0 });\n\nconst count = signal(0);\nconst count$ = toObservable(count);"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use signals for local component state",
            "Keep computed() pure and fast",
            "Avoid writing to signals inside effect()",
            "Prefer immutable updates",
            "Use signals instead of manual subscriptions when possible"
          ]
        },
        {
          "heading": "Quick Reference",
          "points": [
            "Create: signal(value)",
            "Read: signal()",
            "Write: set(value), update(fn)",
            "Derived: computed(fn)",
            "Side effects: effect(fn)",
            "Interop: toSignal(), toObservable()"
          ]
        },
        {
          "heading": "Exercise",
          "question": "How do you read a signal's value?",
          "options": [
            "Call it like a function (e.g., count())",
            "Access .value",
            "Use count.get()"
          ],
          "answer": "Call it like a function (e.g., count())"
        }
      ]
    },

    "angular-change-detection": {
      "title": "Angular Change Detection & Performance",
      "description": "Change detection updates the view when application state changes. Angular provides strategies and tools to control performance and rendering behavior.",
      "sections": [
        {
          "heading": "Change Detection Essentials",
          "points": [
            "Change detection updates the view when state changes",
            "OnPush limits checks to specific triggers",
            "Signals trigger updates explicitly",
            "Use track/trackBy for stable list rendering",
            "Avoid unnecessary DOM updates"
          ]
        },
        {
          "heading": "OnPush Strategy",
          "description": "OnPush improves performance by limiting when Angular checks a component.",
          "code": "import { ChangeDetectionStrategy, signal } from '@angular/core';\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nclass Demo {\n  items = signal([{ id: 1, label: 'A' }]);\n  add() {\n    this.items.update(a => [...a, { id: Date.now(), label: 'N' }]);\n  }\n}"
        },
        {
          "heading": "Example",
          "description": "Using OnPush with signals for predictable rendering.",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, signal, ChangeDetectionStrategy } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule],\n  template: `\n    <h3>OnPush + Signals</h3>\n    <p>Count: {{ count() }}</p>\n    <button (click)=\"inc()\">Increment</button>\n\n    <ul>\n      @for (it of items(); track it.id) {\n        <li>{{ it.label }}</li>\n      }\n    </ul>\n  `\n})\nexport class App {\n  count = signal(0);\n  items = signal([\n    { id: 1, label: 'A' },\n    { id: 2, label: 'B' }\n  ]);\n\n  inc() {\n    this.count.set(this.count() + 1);\n  }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Example Explained",
          "points": [
            "OnPush runs change detection only when inputs, signals, or events change",
            "Signals automatically trigger updates",
            "track it.id prevents DOM re-creation",
            "Immutable updates ensure proper detection"
          ]
        },
        {
          "heading": "Signals & Change Detection",
          "points": [
            "Signals integrate naturally with OnPush",
            "Use computed() for derived values",
            "Use effect() for side effects only",
            "Avoid mutating objects directly"
          ],
          "code": "import { signal, computed, effect } from '@angular/core';\n\nconst count = signal(0);\nconst double = computed(() => count() * 2);\n\neffect(() => console.log('double =', double()));"
        },
        {
          "heading": "Stable Lists with track",
          "points": [
            "Use track to preserve DOM elements",
            "Prevents re-rendering unchanged items",
            "Equivalent to trackBy in *ngFor",
            "Always prefer stable unique IDs"
          ],
          "code": "@for (it of items(); track it.id) {\n  <li>{{ it.label }}</li>\n}"
        },
        {
          "heading": "Performance Tips",
          "points": [
            "Use OnPush wherever possible",
            "Avoid mutating arrays and objects",
            "Use signals instead of manual subscriptions",
            "Use track/trackBy for lists",
            "Keep templates simple"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which Angular change detection strategy limits checks to specific triggers?",
          "options": ["OnPush", "Default", "Aggressive"],
          "answer": "OnPush"
        }
      ]
    },

    "angular-dynamic-components": {
      "title": "Angular Dynamic Components",
      "description": "Dynamic components allow you to create and render components at runtime using createComponent() or *ngComponentOutlet.",
      "sections": [
        {
          "heading": "Dynamic Components Essentials",
          "points": [
            "createComponent() creates components dynamically at runtime",
            "Standalone components can be rendered without selectors",
            "*ngComponentOutlet renders components declaratively",
            "Signals can drive dynamic state",
            "Use EnvironmentInjector to resolve providers"
          ]
        },
        {
          "heading": "createComponent() Basics",
          "description": "Use createComponent() when you need full control over component creation, inputs, outputs, and lifecycle.",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, Input, Output, EventEmitter, ElementRef, ViewChild, inject, EnvironmentInjector, ComponentRef } from '@angular/core';\nimport { createComponent } from '@angular/core';\n\n@Component({\n  standalone: true,\n  template: `\n    <div style=\"padding:8px;border:1px solid #ddd;border-radius:6px;\">\n      <h4>{{ title }}</h4>\n      <button (click)=\"clicked.emit()\">Click</button>\n    </div>\n  `\n})\nexport class Card {\n  @Input() title = 'Card';\n  @Output() clicked = new EventEmitter<void>();\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Dynamic createComponent()</h3>\n    <div #host style=\"border:1px dashed #aaa;padding:8px;\"></div>\n    <button (click)=\"mount()\">Mount</button>\n    <button (click)=\"update()\">Update</button>\n    <button (click)=\"unmount()\">Unmount</button>\n  `\n})\nexport class App {\n  @ViewChild('host', { read: ElementRef }) host!: ElementRef<HTMLElement>;\n  env = inject(EnvironmentInjector);\n  ref: ComponentRef<Card> | null = null;\n\n  mount() {\n    if (this.ref) return;\n    this.ref = createComponent(Card, {\n      environmentInjector: this.env,\n      hostElement: this.host.nativeElement\n    });\n    this.ref.setInput?.('title', 'Hello Dynamic');\n    this.ref.instance.clicked.subscribe(() => alert('Clicked'));\n  }\n\n  update() {\n    this.ref?.setInput?.('title', 'Updated ' + new Date().toLocaleTimeString());\n  }\n\n  unmount() {\n    this.ref?.destroy();\n    this.ref = null;\n  }\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Example Explained",
          "points": [
            "createComponent() creates a component dynamically",
            "environmentInjector provides DI context",
            "hostElement attaches the component to the DOM",
            "setInput() updates inputs dynamically",
            "destroy() removes the component and cleans resources"
          ]
        },
        {
          "heading": "Selectorless Components with *ngComponentOutlet",
          "description": "Use *ngComponentOutlet to render a standalone component declaratively without a selector.",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component, Input, Output, EventEmitter, signal } from '@angular/core';\nimport { NgComponentOutlet } from '@angular/common';\n\n@Component({\n  standalone: true,\n  template: `<button (click)=\"clicked.emit()\">{{ label }}</button>`\n})\nexport class ActionButton {\n  @Input() label = 'Click';\n  @Output() clicked = new EventEmitter<void>();\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [NgComponentOutlet],\n  template: `\n    <h3>ngComponentOutlet</h3>\n    <p>Clicks: {{ clicks() }}</p>\n    <ng-container *ngComponentOutlet=\"ActionButton; inputs: { label: 'Launch' }; outputs: { clicked: onClick }\"></ng-container>\n  `\n})\nexport class App {\n  ActionButton = ActionButton;\n  clicks = signal(0);\n  onClick = () => this.clicks.update(v => v + 1);\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Key Notes",
          "points": [
            "Use createComponent() for advanced control",
            "Use *ngComponentOutlet for simple dynamic rendering",
            "Always destroy dynamically created components",
            "Signals integrate naturally with dynamic components",
            "Inputs and outputs can be passed dynamically"
          ]
        },
        {
          "heading": "Best Practices",
          "points": [
            "Prefer *ngComponentOutlet for simple use cases",
            "Use createComponent() only when necessary",
            "Always clean up with destroy()",
            "Avoid excessive dynamic component creation",
            "Use signals instead of manual change detection"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which API creates a component dynamically at runtime?",
          "options": [
            "bootstrapApplication()",
            "provideRouter()",
            "createComponent()"
          ],
          "answer": "createComponent()"
        }
      ]
    },

    "angular-advanced-di": {
      "title": "Angular Services & Dependency Injection",
      "description": "Advanced DI uses hierarchical injectors, InjectionToken, optional and multi providers, and function-based inject() for flexible and scalable dependency management.",
      "sections": [
        {
          "heading": "Advanced DI Essentials",
          "points": [
            "Hierarchical injectors define provider scope (app, route, component)",
            "InjectionToken is used for non-class values",
            "inject() enables DI outside constructors",
            "Optional dependencies allow graceful fallbacks",
            "Multi providers collect multiple values under one token"
          ]
        },
        {
          "heading": "Injection Tokens",
          "description": "InjectionToken is used when injecting configuration values or non-class dependencies.",
          "code": "import { InjectionToken, inject } from '@angular/core';\n\nexport const CONFIG = new InjectionToken<{ api: string }>('CONFIG');\n\nconst config = inject(CONFIG);"
        },
        {
          "heading": "Providing Tokens",
          "code": "bootstrapApplication(App, {\n  providers: [\n    { provide: CONFIG, useValue: { api: '/api' } }\n  ]\n});"
        },
        {
          "heading": "Multi Providers",
          "description": "Multi providers allow multiple values for the same token.",
          "code": "export const FEATURES = new InjectionToken<string[]>('FEATURES');\n\nbootstrapApplication(App, {\n  providers: [\n    { provide: FEATURES, useValue: 'search', multi: true },\n    { provide: FEATURES, useValue: 'share', multi: true },\n    { provide: FEATURES, useValue: 'ai', multi: true }\n  ]\n});"
        },
        {
          "heading": "Using Multi Providers",
          "code": "import { Component, inject } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `<p>Features: {{ features.join(', ') }}</p>`\n})\nexport class App {\n  features = inject(FEATURES);\n}"
        },
        {
          "heading": "Optional Dependencies",
          "description": "Optional dependencies prevent runtime errors when a provider is missing.",
          "code": "import { InjectionToken, inject } from '@angular/core';\n\nexport const USER_NAME = new InjectionToken<string>('USER_NAME');\n\nconst name = inject(USER_NAME, { optional: true });"
        },
        {
          "heading": "Optional + Multi Example",
          "code": "bootstrapApplication(App, {\n  providers: [\n    { provide: USER_NAME, useValue: 'Dana' },\n    { provide: FEATURES, useValue: 'search', multi: true },\n    { provide: FEATURES, useValue: 'share', multi: true }\n  ]\n});"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use InjectionToken for configuration values",
            "Use multi providers for plugin-style systems",
            "Scope providers at route or component level when possible",
            "Use inject() instead of constructor injection for utilities",
            "Always handle optional dependencies safely"
          ]
        },
        {
          "heading": "Exercise",
          "question": "What should you use for DI configuration values not tied to a class?",
          "options": ["InjectionToken", "OpaqueToken", "AbstractClass"],
          "answer": "InjectionToken"
        }
      ]
    },

    "angular-router-advanced": {
      "title": "Angular Router Advanced",
      "description": "Advanced routing covers functional guards, auxiliary outlets, route data, and preloading strategies for optimized navigation.",
      "sections": [
        {
          "heading": "Router Advanced Essentials",
          "points": [
            "Functional guards and resolvers use inject()",
            "Auxiliary outlets allow multiple views at once",
            "Preloading improves lazy-loaded route performance",
            "Returning a UrlTree redirects navigation"
          ]
        },
        {
          "heading": "Functional Guards",
          "description": "Guards are implemented as functions using inject() instead of classes.",
          "code": "import { inject } from '@angular/core';\nimport { Router } from '@angular/router';\n\nfunction canActivate() {\n  const router = inject(Router);\n  return true || router.createUrlTree(['/']);\n}"
        },
        {
          "heading": "Route Configuration",
          "code": "import { Routes, provideRouter } from '@angular/router';\n\nconst routes: Routes = [\n  { path: 'feature', loadComponent: () => import('./feature').then(m => m.Feature) },\n  { path: 'compose', outlet: 'modal', loadComponent: () => import('./compose').then(m => m.Compose) }\n];\n\nprovideRouter(routes);"
        },
        {
          "heading": "Auxiliary Routes",
          "description": "Auxiliary outlets allow rendering multiple views at once.",
          "example": "URL: /inbox(modal:compose)",
          "notes": [
            "Uses named outlets",
            "Useful for modals or side panels",
            "Declared using outlet property"
          ]
        },
        {
          "heading": "Functional Guard Example",
          "code": "import { signal, inject } from '@angular/core';\nimport { Router } from '@angular/router';\n\nconst isLoggedIn = signal(false);\n\nfunction canActivate() {\n  const router = inject(Router);\n  return isLoggedIn() || router.createUrlTree(['/']);\n}"
        },
        {
          "heading": "canDeactivate & canMatch",
          "description": "Control navigation away from routes or whether a route matches.",
          "code": "import { CanDeactivateFn, CanMatchFn } from '@angular/router';\n\nexport const canDeactivate: CanDeactivateFn<any> = () => confirm('Leave this page?');\n\nexport const canMatch: CanMatchFn = (route, segments) => segments[0]?.path === 'secret';"
        },
        {
          "heading": "Preloading & Route Data",
          "description": "Improve navigation performance using preloading strategies and static route data.",
          "code": "import { withPreloading, PreloadAllModules } from '@angular/router';\n\nprovideRouter(routes, withPreloading(PreloadAllModules));\n\n{ path: 'feature', loadComponent: () => import('./feature').then(m => m.Feature), data: { title: 'Feature' } }"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use functional guards with inject()",
            "Return UrlTree instead of navigating manually",
            "Use route data for metadata",
            "Enable preloading for better UX",
            "Keep guards lightweight and synchronous"
          ]
        },
        {
          "heading": "Exercise",
          "question": "In a functional guard, which return value triggers a redirect?",
          "options": ["UrlTree", "undefined", "HttpResponse"],
          "answer": "UrlTree"
        }
      ]
    },

    "angular-forms-advanced": {
      "title": "Angular Reactive Forms Advanced",
      "description": "Advanced reactive forms model complex data with FormGroup and FormArray, combine sync and async validators, and efficiently update values using patchValue and updateOn.",
      "sections": [
        {
          "heading": "Reactive Forms Advanced Essentials",
          "points": [
            "Use FormGroup and FormArray for complex structures",
            "Combine synchronous and asynchronous validators",
            "Use patchValue for partial updates",
            "Use setValue only when full structure is available"
          ],
          "code": "fb.group({\n  name: ['', Validators.required],\n  tags: fb.array([ fb.group({ label: ['Angular'] }) ])\n});"
        },
        {
          "heading": "FormArray for Dynamic Lists",
          "description": "FormArray represents a dynamic list of form controls or groups.",
          "code": "const tags = fb.array([\n  fb.group({ label: ['Angular'] })\n]);\n\ntags.push(fb.group({ label: [''] }));",
          "notes": [
            "Use FormArray for lists that grow or shrink",
            "Each item should have the same structure",
            "Best used with *ngFor and formGroupName"
          ]
        },
        {
          "heading": "Complete Example",
          "code": "import { ReactiveFormsModule, FormBuilder, Validators, FormArray } from '@angular/forms';\n\nform = this.fb.group({\n  name: ['', Validators.required],\n  tags: this.fb.array([\n    this.fb.group({ label: ['Angular'] })\n  ])\n});\n\nget tags(): FormArray {\n  return this.form.get('tags') as FormArray;\n}\n\naddTag() {\n  this.tags.push(this.fb.group({ label: [''] }));\n}"
        },
        {
          "heading": "Validation Strategies",
          "points": [
            "Use synchronous validators for common rules",
            "Use async validators for server-side checks",
            "Use group-level validators for cross-field validation",
            "Use updateOn to reduce validation frequency"
          ],
          "code": "function banned(words: string[]) {\n  return (c) => words.includes(c.value) ? { banned: true } : null;\n}\n\nfb.control('', [Validators.required, banned(['admin'])]);"
        },
        {
          "heading": "Group-Level Validation",
          "code": "function samePassword(group) {\n  const pass = group.get('pass')?.value;\n  const confirm = group.get('confirm')?.value;\n  return pass === confirm ? null : { mismatch: true };\n}\n\nfb.group(\n  { pass: [''], confirm: [''] },\n  { validators: samePassword, updateOn: 'blur' }\n);",
          "notes": [
            "Use group validators for cross-field checks",
            "Use updateOn: 'blur' or 'submit' for performance",
            "Avoid showing errors before user interaction"
          ]
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use FormArray for dynamic collections",
            "Keep form structure consistent",
            "Use patchValue for partial updates",
            "Debounce async validators",
            "Use trackBy when rendering FormArray rows"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which structure is best for dynamic lists in Reactive Forms?",
          "options": ["FormArray", "FormGroup", "FormControl"],
          "answer": "FormArray"
        }
      ]
    },

    "angular-state-management": {
      "title": "Angular State Management",
      "description": "State management organizes how data changes over time using signals, services, and controlled data flow.",
      "sections": [
        {
          "heading": "State Management Essentials",
          "points": [
            "Start with local component state",
            "Promote to a shared service when state is reused",
            "Use signals for reactive state",
            "Use RxJS only when stream behavior is required"
          ],
          "code": "import { Injectable, signal, computed } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nclass CounterStore {\n  count = signal(0);\n  double = computed(() => this.count() * 2);\n  inc() { this.count.update(n => n + 1); }\n}"
        },
        {
          "heading": "Service-Based State (Store Pattern)",
          "description": "Move shared state into a service so multiple components can access it.",
          "code": "import { Injectable, signal } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nclass CounterStore {\n  count = signal(0);\n  inc() { this.count.update(n => n + 1); }\n}\n\n// Component\nconst store = inject(CounterStore);",
          "notes": [
            "Keeps state centralized",
            "Avoids prop drilling",
            "Improves testability"
          ]
        },
        {
          "heading": "Working Example",
          "code": "import { Component, Injectable, signal, inject } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nclass CounterStore {\n  count = signal(0);\n  inc() { this.count.update(n => n + 1); }\n}\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <p>Count: {{ store.count() }}</p>\n    <button (click)=\"store.inc()\">Increment</button>\n  `\n})\nclass App {\n  store = inject(CounterStore);\n}"
        },
        {
          "heading": "Local vs Global State",
          "points": [
            "Keep state local when only one component uses it",
            "Promote to service when shared across components",
            "Scope services at route level when isolation is needed",
            "Avoid global mutable state"
          ],
          "code": "const routes = [\n  { path: '', component: Home, providers: [CounterStore] }\n];"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use signals for state",
            "Expose state through methods, not direct mutation",
            "Use computed() for derived values",
            "Avoid unnecessary global state",
            "Use services as stores"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Where should shared feature state typically live in Angular?",
          "options": [
            "Inside component local variables",
            "In a service (a store) using signals",
            "As global window properties"
          ],
          "answer": "In a service (a store) using signals"
        }
      ]
    },

    "angular-animations": {
      "title": "Angular Animations",
      "description": "Angular animations are declarative and state-driven. You define triggers, transitions, and animations in the component and control them through data.",
      "sections": [
        {
          "heading": "Animations Essentials",
          "points": [
            "Use trigger() to define an animation",
            "Use state() to define styles",
            "Use transition() to define when animations run",
            "Use animate() to define duration and easing",
            "Enable animations with provideAnimations()"
          ],
          "code": "import { trigger, state, style, transition, animate } from '@angular/animations';\n\n@Component({\n  animations: [\n    trigger('openClose', [\n      state('open', style({ opacity: 1 })),\n      state('closed', style({ opacity: 0 })),\n      transition('open <=> closed', animate('200ms ease-in-out'))\n    ])\n  ]\n})"
        },
        {
          "heading": "Component Animations",
          "description": "Animations are bound in templates and controlled by component state.",
          "code": "import { Component } from '@angular/core';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  animations: [\n    trigger('openClose', [\n      state('open', style({ height: '80px', opacity: 1 })),\n      state('closed', style({ height: '0px', opacity: 0 })),\n      transition('open <=> closed', animate('200ms ease-in-out'))\n    ])\n  ],\n  template: `\n    <button (click)=\"open = !open\">Toggle</button>\n    <div [@openClose]=\"open ? 'open' : 'closed'\">Panel</div>\n  `\n})\nexport class App { open = true; }"
        },
        {
          "heading": "Providing Animations",
          "points": [
            "Use provideAnimations() to enable animations",
            "Use provideNoopAnimations() to disable animations (useful for testing)",
            "Animations must be enabled globally"
          ],
          "code": "import { provideAnimations, provideNoopAnimations } from '@angular/platform-browser/animations';\n\nbootstrapApplication(App, {\n  providers: [provideAnimations()]\n});\n\n// Disable animations\nbootstrapApplication(App, {\n  providers: [provideNoopAnimations()]\n});"
        },
        {
          "heading": "Reusable Animations",
          "description": "Reusable animations can be defined using animation() and reused across components.",
          "code": "import { animation, style, animate } from '@angular/animations';\n\nexport const fadeIn = animation([\n  style({ opacity: 0 }),\n  animate('{{time}} ease-out', style({ opacity: 1 }))\n]);"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Prefer opacity and transform for better performance",
            "Avoid layout-heavy animations (height, width)",
            "Keep animations declarative",
            "Use provideNoopAnimations() in tests",
            "Respect prefers-reduced-motion for accessibility"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which module is used to mock HTTP requests in Angular tests?",
          "options": [
            "HttpClientTestingModule",
            "HttpClientModule",
            "FormsModule"
          ],
          "answer": "HttpClientTestingModule"
        }
      ]
    },

    "angular-testing": {
      "title": "Angular Testing",
      "description": "Angular testing ensures components and services behave correctly using lightweight, fast, and isolated test setups.",
      "sections": [
        {
          "heading": "Testing Essentials",
          "points": [
            "Test components and services with lightweight setups",
            "Use TestBed for creating test environments",
            "Keep logic in pure functions for easy testing",
            "Mock HTTP and router dependencies",
            "Disable animations for stable tests"
          ],
          "code": "import { provideNoopAnimations } from '@angular/platform-browser/animations';\n\nbootstrapApplication(App, {\n  providers: [provideNoopAnimations()]\n});"
        },
        {
          "heading": "Component Smoke Test",
          "description": "A basic test ensures the component renders correctly and logic works as expected.",
          "code": "import { Component } from '@angular/core';\n\n@Component({\n  standalone: true,\n  template: `<p>{{ add(2,3) }}</p>`\n})\nclass App {\n  add(a: number, b: number) {\n    return a + b;\n  }\n}"
        },
        {
          "heading": "Testing Concepts",
          "points": [
            "Interpolation renders expressions in templates",
            "Assertions verify expected output",
            "Use expect(value).toBe(...) for strict checks",
            "Prefer small, deterministic tests"
          ]
        },
        {
          "heading": "Async Testing",
          "description": "Use fakeAsync and tick to test asynchronous behavior deterministically.",
          "code": "import { fakeAsync, tick } from '@angular/core/testing';\n\nit('waits for async work', fakeAsync(() => {\n  let done = false;\n  setTimeout(() => done = true, 10);\n  tick(10);\n  expect(done).toBeTrue();\n}));"
        },
        {
          "heading": "HTTP Testing",
          "description": "Mock HTTP requests using HttpClientTestingModule and HttpTestingController.",
          "code": "import { TestBed } from '@angular/core/testing';\nimport { HttpClient } from '@angular/common/http';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\n\nTestBed.configureTestingModule({\n  imports: [HttpClientTestingModule]\n});\n\nconst http = TestBed.inject(HttpClient);\nconst httpMock = TestBed.inject(HttpTestingController);\n\nhttp.get('/api/todos/1').subscribe(data => expect(data).toBeTruthy());\nhttpMock.expectOne('/api/todos/1').flush({ id: 1, title: 'Test' });\nhttpMock.verify();"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Use HttpClientTestingModule for HTTP mocking",
            "Disable animations with provideNoopAnimations()",
            "Avoid real HTTP or routing in unit tests",
            "Prefer fakeAsync/tick for async behavior",
            "Keep tests isolated and deterministic"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which module do you import to mock HTTP requests in Angular unit tests?",
          "options": [
            "HttpClientTestingModule",
            "HttpClientModule",
            "FormsModule"
          ],
          "answer": "HttpClientTestingModule"
        }
      ]
    },

    "angular-security": {
      "title": "Angular Security",
      "description": "Angular provides built-in security features to protect applications from common web vulnerabilities such as Cross-Site Scripting (XSS).",
      "sections": [
        {
          "heading": "Security Essentials",
          "points": [
            "Angular automatically sanitizes template bindings to prevent XSS",
            "Dangerous values are removed or escaped before rendering",
            "Always use property bindings instead of string concatenation",
            "Avoid bypassing Angular security unless absolutely necessary"
          ],
          "code": "@Component({ template: `<div [innerHTML]=\"html\"></div>` })\nclass C {\n  html = '<b>Hello</b> <script>alert(1)</script>';\n}"
        },
        {
          "heading": "Sanitization Basics",
          "description": "Angular sanitizes values bound to sensitive DOM properties such as innerHTML, src, and href.",
          "points": [
            "Sanitization prevents script injection",
            "Interpolation {{ }} escapes HTML automatically",
            "Property binding ensures sanitizer execution"
          ],
          "code": "<img [src]=\"photoUrl\" />\n<a [href]=\"profileUrl\">Profile</a>"
        },
        {
          "heading": "Example",
          "description": "Angular removes unsafe HTML before rendering.",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>Sanitized HTML</h3>\n    <div [innerHTML]=\"html\"></div>\n  `\n})\nclass App {\n  html = `Hello <script>alert('xss')</script>`;\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Safe DOM Usage",
          "points": [
            "Always use property bindings ([innerHTML], [src], [href])",
            "Avoid string concatenation for URLs or HTML",
            "Do not trust user input",
            "Prefer Angular templates over direct DOM manipulation"
          ]
        },
        {
          "heading": "DomSanitizer",
          "description": "Use DomSanitizer only when absolutely required and with trusted content.",
          "code": "import { DomSanitizer } from '@angular/platform-browser';\n\n// Avoid unless necessary\n// sanitizer.bypassSecurityTrustHtml(value);"
        },
        {
          "heading": "Security Guidelines",
          "points": [
            "Never bypass security for user input",
            "Limit DomSanitizer usage to vetted content",
            "Enable Content Security Policy (CSP)",
            "Prefer Angular bindings over manual DOM updates",
            "Document all security bypasses"
          ]
        },
        {
          "heading": "Exercise",
          "question": "Which threat does Angular's built-in sanitization primarily mitigate?",
          "options": [
            "XSS (Cross-Site Scripting)",
            "CSRF (Cross-Site Request Forgery)",
            "SQL Injection"
          ],
          "answer": "XSS (Cross-Site Scripting)"
        }
      ]
    },

    "angular-ssr": {
      "title": "Angular SSR & Hydration",
      "description": "Server-Side Rendering (SSR) renders HTML on the server, and hydration attaches client-side behavior without re-rendering the DOM.",
      "sections": [
        {
          "heading": "SSR & Hydration Essentials",
          "points": [
            "SSR renders HTML on the server for faster first paint and SEO",
            "Hydration reuses server-rendered HTML on the client",
            "Avoid non-deterministic rendering during SSR",
            "Effects should be idempotent"
          ],
          "code": "@Component({ template: `<div>Hello</div>` })\nclass App {}"
        },
        {
          "heading": "Hydration-safe Checks",
          "points": [
            "Avoid browser-only APIs during server rendering",
            "Use feature detection or platform checks",
            "Only run DOM code in the browser"
          ],
          "code": "const isBrowser = typeof window !== 'undefined';\n\nimport { PLATFORM_ID, inject } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\nconst platformId = inject(PLATFORM_ID);\nconst onBrowser = isPlatformBrowser(platformId);"
        },
        {
          "heading": "Example",
          "description": "Detects browser environment safely during hydration.",
          "code": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n    <h3>SSR & Hydration</h3>\n    <p>Is Browser: {{ isBrowser }}</p>\n  `\n})\nclass App {\n  isBrowser = typeof window !== 'undefined';\n}\n\nbootstrapApplication(App);"
        },
        {
          "heading": "Best Practices",
          "points": [
            "Avoid accessing window or document during SSR",
            "Use TransferState to reuse server-fetched data",
            "Keep rendering deterministic",
            "Avoid random values during render",
            "Defer side effects until hydration completes"
          ]
        },
        {
          "heading": "TransferState",
          "description": "Prevents duplicate HTTP requests between server and client.",
          "code": "import { TransferState, makeStateKey } from '@angular/platform-browser';\n\nconst DATA_KEY = makeStateKey('initial-data');\n// Server: state.set(DATA_KEY, data)\n// Client: state.get(DATA_KEY, null)"
        },
        {
          "heading": "Exercise",
          "question": "What does hydration do in an Angular SSR setup?",
          "options": [
            "Replaces server HTML with brand new client HTML",
            "Reuses server-rendered HTML and wires up event listeners/state",
            "Disables client-side routing"
          ],
          "answer": "Reuses server-rendered HTML and wires up event listeners/state"
        }
      ]
    }
  }
}
